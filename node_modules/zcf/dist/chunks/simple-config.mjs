import { existsSync, readFileSync, writeFileSync, mkdirSync, copyFileSync, readdirSync, statSync, unlinkSync } from 'node:fs';
import process from 'node:process';
import ansis from 'ansis';
import inquirer from 'inquirer';
import { fileURLToPath } from 'node:url';
import i18next from 'i18next';
import Backend from 'i18next-fs-backend';
import { dirname, join } from 'pathe';
import { exec as exec$1 } from 'node:child_process';
import { homedir, platform } from 'node:os';
import { promisify } from 'node:util';
import dayjs from 'dayjs';
import ora from 'ora';
import semver from 'semver';
import { exec } from 'tinyexec';
import { rm, mkdir, copyFile as copyFile$1 } from 'node:fs/promises';

const version = "2.12.7";
const homepage = "https://github.com/UfoMiao/zcf";

const i18n = i18next.createInstance();
const NAMESPACES = [
  "common",
  "api",
  "ccr",
  "cli",
  "cometix",
  "configuration",
  "errors",
  "installation",
  "language",
  "mcp",
  "menu",
  "tools",
  "updater",
  "workflow"
];
function ensureI18nInitialized() {
  if (!i18n.isInitialized) {
    throw new Error(
      "i18n is not initialized. Please call initI18n() in CLI command before using utility functions."
    );
  }
}
async function initI18n(language = "zh-CN") {
  if (i18n.isInitialized) {
    if (i18n.language !== language) {
      await i18n.changeLanguage(language);
    }
    return;
  }
  await i18n.use(Backend).init({
    lng: language,
    fallbackLng: "en",
    // Load all translations as a single flat structure
    ns: NAMESPACES,
    defaultNS: "common",
    preload: [language],
    // Preload the selected language
    // Backend configuration for loading JSON files
    backend: {
      loadPath: (() => {
        const currentDir = dirname(fileURLToPath(import.meta.url));
        const packageRoot = (() => {
          let dir = currentDir;
          while (dir !== dirname(dir)) {
            if (existsSync(join(dir, "package.json"))) {
              return dir;
            }
            dir = dirname(dir);
          }
          return currentDir;
        })();
        const possibleBasePaths = [
          join(currentDir, "locales"),
          // Development: src/i18n/locales
          join(packageRoot, "dist/i18n/locales"),
          // NPM package: /node_modules/zcf/dist/i18n/locales
          join(process.cwd(), "dist/i18n/locales"),
          // Production build: ./dist/i18n/locales
          join(currentDir, "../../../dist/i18n/locales"),
          // Fallback for deep chunk paths
          join(currentDir, "../../i18n/locales")
          // Alternative chunk structure
        ];
        for (const basePath of possibleBasePaths) {
          const testFile = join(basePath, "zh-CN/common.json");
          if (existsSync(testFile)) {
            return join(basePath, "{{lng}}/{{ns}}.json");
          }
        }
        return join(process.cwd(), "dist/i18n/locales/{{lng}}/{{ns}}.json");
      })()
    },
    // Interpolation settings
    interpolation: {
      escapeValue: false
      // Not needed for server-side usage
    },
    // Disable key separator for flat keys, enable namespace separator
    keySeparator: false,
    nsSeparator: ":",
    // Debugging (disable for clean output)
    debug: false
  });
  for (const ns of NAMESPACES) {
    if (ns !== "common") {
      await i18n.loadNamespaces(ns);
    }
  }
}
function format(template, values) {
  if (!values)
    return template;
  return Object.keys(values).reduce((result, key) => {
    return result.replace(new RegExp(`{${key}}`, "g"), values[key]);
  }, template);
}
async function changeLanguage(lng) {
  await i18n.changeLanguage(lng);
}

const MCP_SERVICE_CONFIGS = [
  {
    id: "context7",
    requiresApiKey: false,
    config: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@upstash/context7-mcp"],
      env: {}
    }
  },
  {
    id: "spec-workflow",
    requiresApiKey: false,
    config: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@pimzino/spec-workflow-mcp@latest"],
      env: {}
    }
  },
  {
    id: "mcp-deepwiki",
    requiresApiKey: false,
    config: {
      type: "stdio",
      command: "npx",
      args: ["-y", "mcp-deepwiki@latest"],
      env: {}
    }
  },
  {
    id: "Playwright",
    requiresApiKey: false,
    config: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@playwright/mcp@latest"],
      env: {}
    }
  },
  {
    id: "exa",
    requiresApiKey: true,
    apiKeyEnvVar: "EXA_API_KEY",
    config: {
      type: "stdio",
      command: "npx",
      args: ["-y", "exa-mcp-server"],
      env: {
        EXA_API_KEY: "YOUR_EXA_API_KEY"
      }
    }
  }
];
async function getMcpServices() {
  ensureI18nInitialized();
  const mcpServiceList = [
    {
      id: "Playwright",
      name: i18n.t("mcp:services.Playwright.name"),
      description: i18n.t("mcp:services.Playwright.description")
    },
    {
      id: "context7",
      name: i18n.t("mcp:services.context7.name"),
      description: i18n.t("mcp:services.context7.description")
    },
    {
      id: "exa",
      name: i18n.t("mcp:services.exa.name"),
      description: i18n.t("mcp:services.exa.description"),
      apiKeyPrompt: i18n.t("mcp:services.exa.apiKeyPrompt")
    },
    {
      id: "mcp-deepwiki",
      name: i18n.t("mcp:services.mcp-deepwiki.name"),
      description: i18n.t("mcp:services.mcp-deepwiki.description")
    },
    {
      id: "spec-workflow",
      name: i18n.t("mcp:services.spec-workflow.name"),
      description: i18n.t("mcp:services.spec-workflow.description")
    }
  ];
  return MCP_SERVICE_CONFIGS.map((config) => {
    const serviceInfo = mcpServiceList.find((s) => s.id === config.id);
    const service = {
      id: config.id,
      name: serviceInfo?.name || config.id,
      description: serviceInfo?.description || "",
      requiresApiKey: config.requiresApiKey,
      config: config.config
    };
    if (config.requiresApiKey && serviceInfo?.apiKeyPrompt) {
      if (serviceInfo.apiKeyPrompt !== `mcp.services.${config.id}.apiKeyPrompt`) {
        service.apiKeyPrompt = serviceInfo.apiKeyPrompt;
      }
    }
    if (config.apiKeyEnvVar) {
      service.apiKeyEnvVar = config.apiKeyEnvVar;
    }
    return service;
  });
}

const WORKFLOW_CONFIG_BASE = [
  {
    id: "commonTools",
    defaultSelected: true,
    order: 1,
    commands: ["init-project.md"],
    agents: [
      { id: "init-architect", filename: "init-architect.md", required: true },
      { id: "get-current-datetime", filename: "get-current-datetime.md", required: true }
    ],
    autoInstallAgents: true,
    category: "common",
    outputDir: "common"
  },
  {
    id: "sixStepsWorkflow",
    defaultSelected: true,
    order: 2,
    commands: ["workflow.md"],
    agents: [],
    autoInstallAgents: false,
    category: "sixStep",
    outputDir: "workflow"
  },
  {
    id: "featPlanUx",
    defaultSelected: true,
    order: 3,
    commands: ["feat.md"],
    agents: [
      { id: "planner", filename: "planner.md", required: true },
      { id: "ui-ux-designer", filename: "ui-ux-designer.md", required: true }
    ],
    autoInstallAgents: true,
    category: "plan",
    outputDir: "feat"
  },
  {
    id: "gitWorkflow",
    defaultSelected: true,
    order: 4,
    commands: ["git-commit.md", "git-rollback.md", "git-cleanBranches.md", "git-worktree.md"],
    agents: [],
    autoInstallAgents: false,
    category: "git",
    outputDir: "git"
  },
  {
    id: "bmadWorkflow",
    defaultSelected: true,
    order: 5,
    commands: ["bmad-init.md"],
    agents: [],
    autoInstallAgents: false,
    category: "bmad",
    outputDir: "bmad"
  }
];
function getWorkflowConfigs() {
  ensureI18nInitialized();
  const workflowTranslations = [
    {
      id: "commonTools",
      name: i18n.t("workflow:workflowOption.commonTools"),
      description: i18n.t("workflow:workflowDescription.commonTools")
    },
    {
      id: "sixStepsWorkflow",
      name: i18n.t("workflow:workflowOption.sixStepsWorkflow"),
      description: i18n.t("workflow:workflowDescription.sixStepsWorkflow")
    },
    {
      id: "featPlanUx",
      name: i18n.t("workflow:workflowOption.featPlanUx"),
      description: i18n.t("workflow:workflowDescription.featPlanUx")
    },
    {
      id: "gitWorkflow",
      name: i18n.t("workflow:workflowOption.gitWorkflow"),
      description: i18n.t("workflow:workflowDescription.gitWorkflow")
    },
    {
      id: "bmadWorkflow",
      name: i18n.t("workflow:workflowOption.bmadWorkflow"),
      description: i18n.t("workflow:workflowDescription.bmadWorkflow")
    }
  ];
  return WORKFLOW_CONFIG_BASE.map((baseConfig) => {
    const translation = workflowTranslations.find((t) => t.id === baseConfig.id);
    return {
      ...baseConfig,
      name: translation?.name || baseConfig.id,
      description: translation?.description
    };
  });
}
function getWorkflowConfig(workflowId) {
  return getWorkflowConfigs().find((config) => config.id === workflowId);
}
function getOrderedWorkflows() {
  return getWorkflowConfigs().sort((a, b) => a.order - b.order);
}

const CLAUDE_DIR = join(homedir(), ".claude");
const SETTINGS_FILE = join(CLAUDE_DIR, "settings.json");
const CLAUDE_MD_FILE = join(CLAUDE_DIR, "CLAUDE.md");
const ClAUDE_CONFIG_FILE = join(homedir(), ".claude.json");
const LEGACY_ZCF_CONFIG_FILE = join(homedir(), ".zcf.json");
const ZCF_CONFIG_FILE = join(CLAUDE_DIR, ".zcf-config.json");
const SUPPORTED_LANGS = ["zh-CN", "en"];
const LANG_LABELS = {
  "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
  "en": "English"
};
const AI_OUTPUT_LANGUAGES = {
  "zh-CN": { directive: "Always respond in Chinese-simplified" },
  "en": { directive: "Always respond in English" },
  "custom": { directive: "" }
};
let _i18n = null;
function getI18nInstance() {
  if (!_i18n) {
    try {
      const i18nModule = eval('require("./i18n")');
      _i18n = i18nModule.i18n;
    } catch {
    }
  }
  return _i18n;
}
function getAiOutputLanguageLabel(lang) {
  if (lang in LANG_LABELS) {
    return LANG_LABELS[lang];
  }
  const i18n = getI18nInstance();
  if (lang === "custom" && i18n?.isInitialized) {
    try {
      return i18n.t("language:labels.custom");
    } catch {
    }
  }
  return lang;
}

function getDisplayWidth(str) {
  let width = 0;
  for (const char of str) {
    if (char.match(/[\u4E00-\u9FFF\uFF01-\uFF60\u3000-\u303F]/)) {
      width += 2;
    } else {
      width += 1;
    }
  }
  return width;
}
function padToDisplayWidth(str, targetWidth) {
  const currentWidth = getDisplayWidth(str);
  const paddingNeeded = Math.max(0, targetWidth - currentWidth);
  return str + " ".repeat(paddingNeeded);
}
function displayBanner(subtitle) {
  ensureI18nInitialized();
  const defaultSubtitle = i18n.t("cli:banner.subtitle");
  const subtitleText = subtitle || defaultSubtitle;
  const paddedSubtitle = padToDisplayWidth(subtitleText, 60);
  console.log(
    ansis.cyan.bold(`
\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557
\u2551                                                                \u2551
\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557                                   \u2551
\u2551       \u2588\u2588\u2554\u255D  \u2588\u2588\u2554\u2550\u2550\u2550\u255D  \u2588\u2588\u2554\u2550\u2550\u2550\u255D                                   \u2551
\u2551      \u2588\u2588\u2554\u255D   \u2588\u2588\u2551      \u2588\u2588\u2588\u2588\u2588\u2557                                    \u2551
\u2551    \u2588\u2588\u2554\u255D     \u2588\u2588\u2551      \u2588\u2588\u2554\u2550\u2550\u255D                                    \u2551
\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551                                       \u2551
\u2551   \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D   \u255A\u2550\u2550\u2550\u2550\u2550\u255D \u255A\u2550\u255D                                       \u2551
\u2551                                                                \u2551
\u2551   ${ansis.white.bold("Zero-Config Claude-Code Flow")}                                 \u2551
\u2551   ${ansis.gray(paddedSubtitle)} \u2551
\u2551                                                                \u2551
\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D
`)
  );
}
function displayBannerWithInfo(subtitle) {
  displayBanner(subtitle);
  console.log(ansis.gray(`  Version: ${ansis.cyan(version)}  |  ${ansis.cyan(homepage)}
`));
}

class FileSystemError extends Error {
  constructor(message, path, cause) {
    super(message);
    this.path = path;
    this.cause = cause;
    this.name = "FileSystemError";
  }
}
function exists(path) {
  return existsSync(path);
}
function ensureDir(path) {
  if (!existsSync(path)) {
    mkdirSync(path, { recursive: true });
  }
}
function ensureFileDir(filePath) {
  const dir = dirname(filePath);
  ensureDir(dir);
}
function readFile(path, encoding = "utf-8") {
  try {
    return readFileSync(path, encoding);
  } catch (error) {
    throw new FileSystemError(
      `Failed to read file: ${path}`,
      path,
      error
    );
  }
}
function writeFile(path, content, encoding = "utf-8") {
  try {
    ensureFileDir(path);
    writeFileSync(path, content, encoding);
  } catch (error) {
    throw new FileSystemError(
      `Failed to write file: ${path}`,
      path,
      error
    );
  }
}
function copyFile(src, dest) {
  try {
    ensureFileDir(dest);
    copyFileSync(src, dest);
  } catch (error) {
    throw new FileSystemError(
      `Failed to copy file from ${src} to ${dest}`,
      src,
      error
    );
  }
}
function readDir(path) {
  try {
    return readdirSync(path);
  } catch (error) {
    throw new FileSystemError(
      `Failed to read directory: ${path}`,
      path,
      error
    );
  }
}
function getStats(path) {
  try {
    return statSync(path);
  } catch (error) {
    throw new FileSystemError(
      `Failed to get stats for: ${path}`,
      path,
      error
    );
  }
}
function removeFile(path) {
  try {
    if (exists(path)) {
      unlinkSync(path);
    }
  } catch (error) {
    throw new FileSystemError(
      `Failed to remove file: ${path}`,
      path,
      error
    );
  }
}
function copyDir(src, dest, options = {}) {
  const { filter, overwrite = true } = options;
  if (!exists(src)) {
    throw new FileSystemError(`Source directory does not exist: ${src}`, src);
  }
  ensureDir(dest);
  const entries = readDir(src);
  for (const entry of entries) {
    const srcPath = `${src}/${entry}`;
    const destPath = `${dest}/${entry}`;
    const stats = getStats(srcPath);
    if (filter && !filter(srcPath, stats)) {
      continue;
    }
    if (stats.isDirectory()) {
      copyDir(srcPath, destPath, options);
    } else {
      if (!overwrite && exists(destPath)) {
        continue;
      }
      copyFile(srcPath, destPath);
    }
  }
}

function readJsonConfig(path, options = {}) {
  const { defaultValue = null, validate, sanitize } = options;
  if (!exists(path)) {
    return defaultValue;
  }
  try {
    const content = readFile(path);
    const data = JSON.parse(content);
    if (validate && !validate(data)) {
      console.log(`Invalid configuration: ${path}`);
      return defaultValue;
    }
    if (sanitize) {
      return sanitize(data);
    }
    return data;
  } catch (error) {
    console.error(`Failed to parse JSON: ${path}`, error);
    return defaultValue;
  }
}
function writeJsonConfig(path, data, options = {}) {
  const { pretty = true, backup = false, backupDir } = options;
  if (backup && exists(path)) {
    backupJsonConfig(path, backupDir);
  }
  const content = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
  writeFile(path, content);
}
function backupJsonConfig(path, backupDir) {
  if (!exists(path)) {
    return null;
  }
  const timestamp = dayjs().format("YYYY-MM-DD_HH-mm-ss");
  const fileName = path.split("/").pop() || "config.json";
  const baseDir = backupDir || join(path, "..", "backup");
  const backupPath = join(baseDir, `${fileName}.backup_${timestamp}`);
  try {
    ensureDir(baseDir);
    copyFile(path, backupPath);
    return backupPath;
  } catch (error) {
    console.error("Failed to backup config", error);
    return null;
  }
}

function mergeArraysUnique(arr1, arr2) {
  const combined = [...arr1 || [], ...arr2 || []];
  return [...new Set(combined)];
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && value.constructor === Object && Object.prototype.toString.call(value) === "[object Object]";
}
function deepMerge(target, source, options = {}) {
  const { mergeArrays = false, arrayMergeStrategy = "replace" } = options;
  const result = { ...target };
  for (const key in source) {
    const sourceValue = source[key];
    const targetValue = result[key];
    if (sourceValue === void 0) {
      continue;
    }
    if (isPlainObject(sourceValue) && isPlainObject(targetValue)) {
      result[key] = deepMerge(targetValue, sourceValue, options);
    } else if (Array.isArray(sourceValue)) {
      if (!mergeArrays || !Array.isArray(targetValue)) {
        result[key] = sourceValue;
      } else {
        switch (arrayMergeStrategy) {
          case "concat":
            result[key] = [...targetValue, ...sourceValue];
            break;
          case "unique":
            result[key] = mergeArraysUnique(targetValue, sourceValue);
            break;
          case "replace":
          default:
            result[key] = sourceValue;
            break;
        }
      }
    } else {
      result[key] = sourceValue;
    }
  }
  return result;
}
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item));
  }
  if (isPlainObject(obj)) {
    const cloned = {};
    for (const key in obj) {
      cloned[key] = deepClone(obj[key]);
    }
    return cloned;
  }
  return obj;
}

function getPlatform() {
  const p = platform();
  if (p === "win32")
    return "windows";
  if (p === "darwin")
    return "macos";
  return "linux";
}
function isTermux() {
  return !!(process.env.PREFIX && process.env.PREFIX.includes("com.termux")) || !!process.env.TERMUX_VERSION || existsSync("/data/data/com.termux/files/usr");
}
function getTermuxPrefix() {
  return process.env.PREFIX || "/data/data/com.termux/files/usr";
}
function isWindows() {
  return getPlatform() === "windows";
}
function getMcpCommand() {
  if (isWindows()) {
    return ["cmd", "/c", "npx"];
  }
  return ["npx"];
}
async function commandExists(command) {
  try {
    const cmd = getPlatform() === "windows" ? "where" : "which";
    const res = await exec(cmd, [command]);
    if (res.exitCode === 0) {
      return true;
    }
  } catch {
  }
  if (isTermux()) {
    const termuxPrefix = getTermuxPrefix();
    const possiblePaths = [
      `${termuxPrefix}/bin/${command}`,
      `${termuxPrefix}/usr/bin/${command}`,
      `/data/data/com.termux/files/usr/bin/${command}`
    ];
    for (const path of possiblePaths) {
      if (existsSync(path)) {
        return true;
      }
    }
  }
  if (getPlatform() !== "windows") {
    const commonPaths = [
      `/usr/local/bin/${command}`,
      `/usr/bin/${command}`,
      `/bin/${command}`,
      `${process.env.HOME}/.local/bin/${command}`
    ];
    for (const path of commonPaths) {
      if (existsSync(path)) {
        return true;
      }
    }
  }
  return false;
}

function getMcpConfigPath() {
  return ClAUDE_CONFIG_FILE;
}
function readMcpConfig() {
  return readJsonConfig(ClAUDE_CONFIG_FILE);
}
function writeMcpConfig(config) {
  writeJsonConfig(ClAUDE_CONFIG_FILE, config);
}
function backupMcpConfig() {
  const backupBaseDir = join(CLAUDE_DIR, "backup");
  return backupJsonConfig(ClAUDE_CONFIG_FILE, backupBaseDir);
}
function mergeMcpServers(existing, newServers) {
  const config = existing || { mcpServers: {} };
  if (!config.mcpServers) {
    config.mcpServers = {};
  }
  Object.assign(config.mcpServers, newServers);
  return config;
}
function applyPlatformCommand(config) {
  if (config.command === "npx" && isWindows()) {
    const mcpCmd = getMcpCommand();
    config.command = mcpCmd[0];
    config.args = [...mcpCmd.slice(1), ...config.args || []];
  }
}
function buildMcpServerConfig(baseConfig, apiKey, placeholder = "YOUR_EXA_API_KEY", envVarName) {
  const config = deepClone(baseConfig);
  applyPlatformCommand(config);
  if (!apiKey) {
    return config;
  }
  if (envVarName && config.env) {
    config.env[envVarName] = apiKey;
    return config;
  }
  if (config.args) {
    config.args = config.args.map((arg) => arg.replace(placeholder, apiKey));
  }
  if (config.url) {
    config.url = config.url.replace(placeholder, apiKey);
  }
  return config;
}
function fixWindowsMcpConfig(config) {
  if (!isWindows() || !config.mcpServers) {
    return config;
  }
  const fixed = { ...config };
  for (const [, serverConfig] of Object.entries(fixed.mcpServers)) {
    if (serverConfig && typeof serverConfig === "object" && "command" in serverConfig) {
      applyPlatformCommand(serverConfig);
    }
  }
  return fixed;
}
function addCompletedOnboarding() {
  try {
    let config = readMcpConfig();
    if (!config) {
      config = { mcpServers: {} };
    }
    if (config.hasCompletedOnboarding === true) {
      return;
    }
    config.hasCompletedOnboarding = true;
    writeMcpConfig(config);
  } catch (error) {
    console.error("Failed to add onboarding flag", error);
    throw error;
  }
}

function cleanupPermissions(templatePermissions, userPermissions) {
  const templateSet = new Set(templatePermissions);
  const cleanedPermissions = userPermissions.filter((permission) => {
    if (["mcp__.*", "mcp__*", "mcp__(*)"].includes(permission)) {
      return false;
    }
    for (const templatePerm of templatePermissions) {
      if (permission === templatePerm) {
        continue;
      }
      if (permission.startsWith(templatePerm)) {
        return false;
      }
    }
    return true;
  });
  const merged = [...templateSet];
  for (const permission of cleanedPermissions) {
    if (!templateSet.has(permission)) {
      merged.push(permission);
    }
  }
  return merged;
}
function mergeAndCleanPermissions(templatePermissions, userPermissions) {
  const template = templatePermissions || [];
  const user = userPermissions || [];
  return cleanupPermissions(template, user);
}

function ensureClaudeDir() {
  ensureDir(CLAUDE_DIR);
}
function backupExistingConfig() {
  if (!exists(CLAUDE_DIR)) {
    return null;
  }
  const timestamp = dayjs().format("YYYY-MM-DD_HH-mm-ss");
  const backupBaseDir = join(CLAUDE_DIR, "backup");
  const backupDir = join(backupBaseDir, `backup_${timestamp}`);
  ensureDir(backupDir);
  const filter = (path) => {
    return !path.includes("/backup");
  };
  copyDir(CLAUDE_DIR, backupDir, { filter });
  return backupDir;
}
function copyConfigFiles(onlyMd = false) {
  const currentFilePath = fileURLToPath(import.meta.url);
  const distDir = dirname(dirname(currentFilePath));
  const rootDir = dirname(distDir);
  const baseTemplateDir = join(rootDir, "templates");
  if (!onlyMd) {
    const baseSettingsPath = join(baseTemplateDir, "common", "settings.json");
    const destSettingsPath = join(CLAUDE_DIR, "settings.json");
    if (exists(baseSettingsPath)) {
      mergeSettingsFile(baseSettingsPath, destSettingsPath);
    }
  }
}
function getDefaultSettings() {
  try {
    const currentFilePath = fileURLToPath(import.meta.url);
    const distDir = dirname(dirname(currentFilePath));
    const rootDir = dirname(distDir);
    const templateSettingsPath = join(rootDir, "templates", "common", "settings.json");
    return readJsonConfig(templateSettingsPath) || {};
  } catch (error) {
    console.error("Failed to read template settings", error);
    return {};
  }
}
function configureApi(apiConfig) {
  if (!apiConfig)
    return null;
  let settings = getDefaultSettings();
  const existingSettings = readJsonConfig(SETTINGS_FILE);
  if (existingSettings) {
    settings = deepMerge(settings, existingSettings);
  }
  if (!settings.env) {
    settings.env = {};
  }
  if (apiConfig.authType === "api_key") {
    settings.env.ANTHROPIC_API_KEY = apiConfig.key;
    delete settings.env.ANTHROPIC_AUTH_TOKEN;
  } else if (apiConfig.authType === "auth_token") {
    settings.env.ANTHROPIC_AUTH_TOKEN = apiConfig.key;
    delete settings.env.ANTHROPIC_API_KEY;
  }
  if (apiConfig.url) {
    settings.env.ANTHROPIC_BASE_URL = apiConfig.url;
  }
  writeJsonConfig(SETTINGS_FILE, settings);
  try {
    addCompletedOnboarding();
  } catch (error) {
    console.error("Failed to set onboarding flag", error);
  }
  return apiConfig;
}
function mergeConfigs(sourceFile, targetFile) {
  if (!exists(sourceFile))
    return;
  const target = readJsonConfig(targetFile) || {};
  const source = readJsonConfig(sourceFile) || {};
  const merged = deepMerge(target, source);
  writeJsonConfig(targetFile, merged);
}
function updateDefaultModel(model) {
  let settings = getDefaultSettings();
  const existingSettings = readJsonConfig(SETTINGS_FILE);
  if (existingSettings) {
    settings = existingSettings;
  }
  if (model === "default") {
    delete settings.model;
  } else {
    settings.model = model;
  }
  writeJsonConfig(SETTINGS_FILE, settings);
}
function mergeSettingsFile(templatePath, targetPath) {
  try {
    const templateSettings = readJsonConfig(templatePath);
    if (!templateSettings) {
      console.error("Failed to read template settings");
      return;
    }
    if (!exists(targetPath)) {
      writeJsonConfig(targetPath, templateSettings);
      return;
    }
    const existingSettings = readJsonConfig(targetPath) || {};
    const mergedEnv = {
      ...templateSettings.env || {},
      // Template env vars first
      ...existingSettings.env || {}
      // User's env vars override (preserving API keys, etc.)
    };
    const mergedSettings = deepMerge(templateSettings, existingSettings, {
      mergeArrays: true,
      arrayMergeStrategy: "unique"
    });
    mergedSettings.env = mergedEnv;
    if (mergedSettings.permissions && mergedSettings.permissions.allow) {
      mergedSettings.permissions.allow = mergeAndCleanPermissions(
        templateSettings.permissions?.allow,
        existingSettings.permissions?.allow
      );
    }
    writeJsonConfig(targetPath, mergedSettings);
  } catch (error) {
    console.error("Failed to merge settings", error);
    if (exists(targetPath)) {
      console.log("Preserving existing settings");
    } else {
      copyFile(templatePath, targetPath);
    }
  }
}
function getExistingModelConfig() {
  const settings = readJsonConfig(SETTINGS_FILE);
  if (!settings) {
    return null;
  }
  if (!settings.model) {
    return "default";
  }
  return settings.model;
}
function getExistingApiConfig() {
  const settings = readJsonConfig(SETTINGS_FILE);
  if (!settings || !settings.env) {
    return null;
  }
  const { ANTHROPIC_API_KEY, ANTHROPIC_AUTH_TOKEN, ANTHROPIC_BASE_URL } = settings.env;
  if (!ANTHROPIC_BASE_URL && !ANTHROPIC_API_KEY && !ANTHROPIC_AUTH_TOKEN) {
    return null;
  }
  let authType;
  let key;
  if (ANTHROPIC_AUTH_TOKEN) {
    authType = "auth_token";
    key = ANTHROPIC_AUTH_TOKEN;
  } else if (ANTHROPIC_API_KEY) {
    authType = "api_key";
    key = ANTHROPIC_API_KEY;
  }
  return {
    url: ANTHROPIC_BASE_URL || "",
    key: key || "",
    authType
  };
}
function applyAiLanguageDirective(aiOutputLang) {
  const claudeFile = join(CLAUDE_DIR, "CLAUDE.md");
  let directive = "";
  if (aiOutputLang === "custom") {
    return;
  } else if (AI_OUTPUT_LANGUAGES[aiOutputLang]) {
    directive = AI_OUTPUT_LANGUAGES[aiOutputLang].directive;
  } else {
    directive = `Always respond in ${aiOutputLang}`;
  }
  writeFile(claudeFile, directive);
}

const PROVIDER_PRESETS_URL = "https://pub-0dc3e1677e894f07bbea11b17a29e032.r2.dev/providers.json";
async function fetchProviderPresets() {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5e3);
    const response = await fetch(PROVIDER_PRESETS_URL, {
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    const presets = [];
    if (Array.isArray(data)) {
      for (const provider of data) {
        if (provider && typeof provider === "object") {
          presets.push({
            name: provider.name || "",
            provider: provider.name || "",
            baseURL: provider.api_base_url || provider.baseURL || provider.url,
            requiresApiKey: provider.api_key === "" || provider.requiresApiKey !== false,
            models: provider.models || [],
            description: provider.description || provider.name || "",
            transformer: provider.transformer
          });
        }
      }
    } else if (data && typeof data === "object") {
      for (const [key, value] of Object.entries(data)) {
        if (typeof value === "object" && value !== null) {
          const provider = value;
          presets.push({
            name: provider.name || key,
            provider: key,
            baseURL: provider.api_base_url || provider.baseURL || provider.url,
            requiresApiKey: provider.api_key === "" || provider.requiresApiKey !== false,
            models: provider.models || [],
            description: provider.description || "",
            transformer: provider.transformer
          });
        }
      }
    }
    return presets;
  } catch {
    return getFallbackPresets();
  }
}
function getFallbackPresets() {
  return [
    {
      name: "dashscope",
      provider: "dashscope",
      baseURL: "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions",
      requiresApiKey: true,
      models: ["qwen3-coder-plus"],
      description: "Alibaba DashScope",
      transformer: {
        "use": [["maxtoken", { max_tokens: 65536 }]],
        "qwen3-coder-plus": {
          use: ["enhancetool"]
        }
      }
    },
    {
      name: "deepseek",
      provider: "deepseek",
      baseURL: "https://api.deepseek.com/chat/completions",
      requiresApiKey: true,
      models: ["deepseek-chat", "deepseek-reasoner"],
      description: "DeepSeek AI models",
      transformer: {
        "use": ["deepseek"],
        "deepseek-chat": {
          use: ["tooluse"]
        }
      }
    },
    {
      name: "gemini",
      provider: "gemini",
      baseURL: "https://generativelanguage.googleapis.com/v1beta/models/",
      requiresApiKey: true,
      models: ["gemini-2.5-flash", "gemini-2.5-pro"],
      description: "Google Gemini models",
      transformer: {
        use: ["gemini"]
      }
    },
    {
      name: "modelscope",
      provider: "modelscope",
      baseURL: "https://api-inference.modelscope.cn/v1/chat/completions",
      requiresApiKey: true,
      models: ["Qwen/Qwen3-Coder-480B-A35B-Instruct", "Qwen/Qwen3-235B-A22B-Thinking-2507", "ZhipuAI/GLM-4.5"],
      description: "ModelScope AI models",
      transformer: {
        "use": [["maxtoken", { max_tokens: 65536 }]],
        "Qwen/Qwen3-Coder-480B-A35B-Instruct": {
          use: ["enhancetool"]
        },
        "Qwen/Qwen3-235B-A22B-Thinking-2507": {
          use: ["reasoning"]
        }
      }
    },
    {
      name: "openrouter",
      provider: "openrouter",
      baseURL: "https://openrouter.ai/api/v1/chat/completions",
      requiresApiKey: true,
      models: [
        "google/gemini-2.5-pro-preview",
        "anthropic/claude-sonnet-4",
        "anthropic/claude-3.5-sonnet",
        "anthropic/claude-3.7-sonnet:thinking"
      ],
      description: "OpenRouter API",
      transformer: {
        use: ["openrouter"]
      }
    },
    {
      name: "siliconflow",
      provider: "siliconflow",
      baseURL: "https://api.siliconflow.cn/v1/chat/completions",
      requiresApiKey: true,
      models: ["moonshotai/Kimi-K2-Instruct"],
      description: "SiliconFlow AI",
      transformer: {
        use: [["maxtoken", { max_tokens: 16384 }]]
      }
    },
    {
      name: "volcengine",
      provider: "volcengine",
      baseURL: "https://ark.cn-beijing.volces.com/api/v3/chat/completions",
      requiresApiKey: true,
      models: ["deepseek-v3-250324", "deepseek-r1-250528"],
      description: "Volcengine AI",
      transformer: {
        use: ["deepseek"]
      }
    }
  ];
}

const execAsync$4 = promisify(exec$1);
const CCR_CONFIG_DIR = join(homedir(), ".claude-code-router");
const CCR_CONFIG_FILE = join(CCR_CONFIG_DIR, "config.json");
const CCR_BACKUP_DIR = CCR_CONFIG_DIR;
function ensureCcrConfigDir() {
  if (!existsSync(CCR_CONFIG_DIR)) {
    mkdirSync(CCR_CONFIG_DIR, { recursive: true });
  }
}
async function backupCcrConfig() {
  ensureI18nInitialized();
  try {
    if (!existsSync(CCR_CONFIG_FILE)) {
      return null;
    }
    const timestamp = `${dayjs().format("YYYY-MM-DDTHH-mm-ss-SSS")}Z`;
    const backupFileName = `config.json.${timestamp}.bak`;
    const backupPath = join(CCR_BACKUP_DIR, backupFileName);
    console.log(ansis.cyan(`${i18n.t("ccr:backupCcrConfig")}`));
    copyFileSync(CCR_CONFIG_FILE, backupPath);
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrBackupSuccess").replace("{path}", backupPath)}`));
    return backupPath;
  } catch (error) {
    console.error(ansis.red(`${i18n.t("ccr:ccrBackupFailed")}:`), error.message);
    return null;
  }
}
function readCcrConfig() {
  if (!existsSync(CCR_CONFIG_FILE)) {
    return null;
  }
  return readJsonConfig(CCR_CONFIG_FILE);
}
function writeCcrConfig(config) {
  ensureCcrConfigDir();
  writeJsonConfig(CCR_CONFIG_FILE, config);
}
async function configureCcrProxy(ccrConfig) {
  const settings = readJsonConfig(SETTINGS_FILE) || {};
  const host = ccrConfig.HOST || "127.0.0.1";
  const port = ccrConfig.PORT || 3456;
  const apiKey = ccrConfig.APIKEY || "sk-zcf-x-ccr";
  if (!settings.env) {
    settings.env = {};
  }
  settings.env.ANTHROPIC_BASE_URL = `http://${host}:${port}`;
  settings.env.ANTHROPIC_API_KEY = apiKey;
  writeJsonConfig(SETTINGS_FILE, settings);
}
async function selectCcrPreset() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`${i18n.t("ccr:fetchingPresets")}`));
  const presets = await fetchProviderPresets();
  if (!presets || presets.length === 0) {
    console.log(ansis.yellow(`${i18n.t("ccr:noPresetsAvailable")}`));
    return null;
  }
  try {
    const choices = [
      {
        name: `1. ${i18n.t("ccr:skipOption")}`,
        value: "skip"
      },
      ...presets.map((p, index) => ({
        name: `${index + 2}. ${p.name}`,
        value: p
      }))
    ];
    const { preset } = await inquirer.prompt({
      type: "list",
      name: "preset",
      message: i18n.t("ccr:selectCcrPreset"),
      choices
    });
    return preset;
  } catch (error) {
    if (error.name === "ExitPromptError") {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return null;
    }
    throw error;
  }
}
async function configureCcrWithPreset(preset) {
  ensureI18nInitialized();
  const provider = {
    name: preset.name,
    // Use the original name from JSON
    api_base_url: preset.baseURL || "",
    api_key: "",
    models: preset.models
  };
  if (preset.transformer) {
    provider.transformer = preset.transformer;
  }
  if (preset.requiresApiKey) {
    try {
      const { apiKey } = await inquirer.prompt({
        type: "input",
        name: "apiKey",
        message: i18n.t("ccr:enterApiKeyForProvider").replace("{provider}", preset.name),
        validate: async (value) => !!value || i18n.t("api:keyRequired")
      });
      provider.api_key = apiKey;
    } catch (error) {
      if (error.name === "ExitPromptError") {
        throw error;
      }
      throw error;
    }
  } else {
    provider.api_key = "sk-free";
  }
  let defaultModel = preset.models[0];
  if (preset.models.length > 1) {
    try {
      const { model } = await inquirer.prompt({
        type: "list",
        name: "model",
        message: i18n.t("ccr:selectDefaultModelForProvider").replace("{provider}", preset.name),
        choices: preset.models.map((m, index) => ({
          name: `${index + 1}. ${m}`,
          value: m
        }))
      });
      defaultModel = model;
    } catch (error) {
      if (error.name === "ExitPromptError") {
        throw error;
      }
      throw error;
    }
  }
  const router = {
    default: `${preset.name},${defaultModel}`,
    // Use the original name
    background: `${preset.name},${defaultModel}`,
    think: `${preset.name},${defaultModel}`,
    longContext: `${preset.name},${defaultModel}`,
    longContextThreshold: 6e4,
    webSearch: `${preset.name},${defaultModel}`
  };
  const config = {
    LOG: true,
    CLAUDE_PATH: "",
    HOST: "127.0.0.1",
    PORT: 3456,
    APIKEY: "sk-zcf-x-ccr",
    API_TIMEOUT_MS: "600000",
    PROXY_URL: "",
    transformers: [],
    Providers: [provider],
    Router: router
  };
  return config;
}
async function restartAndCheckCcrStatus() {
  ensureI18nInitialized();
  try {
    console.log(ansis.cyan(`${i18n.t("ccr:restartingCcr")}`));
    await execAsync$4("ccr restart");
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrRestartSuccess")}`));
    console.log(ansis.cyan(`${i18n.t("ccr:checkingCcrStatus")}`));
    const { stdout } = await execAsync$4("ccr status");
    console.log(ansis.gray(stdout));
  } catch (error) {
    console.error(ansis.red(`${i18n.t("ccr:ccrRestartFailed")}:`), error.message || error);
    if (process.env.DEBUG) {
      console.error("Full error:", error);
    }
  }
}
async function showConfigurationTips(apiKey) {
  ensureI18nInitialized();
  console.log(ansis.bold.cyan(`
\u{1F4CC} ${i18n.t("ccr:configTips")}:`));
  console.log(ansis.blue(`  \u2022 ${i18n.t("ccr:advancedConfigTip")}`));
  console.log(ansis.blue(`  \u2022 ${i18n.t("ccr:manualConfigTip")}`));
  console.log(ansis.bold.yellow(`  \u2022 ${i18n.t("ccr:useClaudeCommand")}`));
  if (apiKey) {
    console.log(ansis.bold.green(`  \u2022 ${i18n.t("ccr:ccrUiApiKey") || "CCR UI API Key"}: ${apiKey}`));
    console.log(ansis.gray(`    ${i18n.t("ccr:ccrUiApiKeyHint") || "Use this API key to login to CCR UI"}`));
  }
  console.log("");
}
function createDefaultCcrConfig() {
  return {
    LOG: false,
    CLAUDE_PATH: "",
    HOST: "127.0.0.1",
    PORT: 3456,
    APIKEY: "sk-zcf-x-ccr",
    API_TIMEOUT_MS: "600000",
    PROXY_URL: "",
    transformers: [],
    Providers: [],
    // Empty providers array - user configures in UI
    Router: {}
    // Empty router configuration - user configures in UI
  };
}
async function setupCcrConfiguration() {
  ensureI18nInitialized();
  try {
    const existingConfig = readCcrConfig();
    if (existingConfig) {
      console.log(ansis.blue(`\u2139 ${i18n.t("ccr:existingCcrConfig")}`));
      let shouldBackupAndReconfigure = false;
      try {
        const result = await inquirer.prompt({
          type: "confirm",
          name: "overwrite",
          message: i18n.t("ccr:overwriteCcrConfig"),
          default: false
        });
        shouldBackupAndReconfigure = result.overwrite;
      } catch (error) {
        if (error.name === "ExitPromptError") {
          console.log(ansis.yellow(i18n.t("common:cancelled")));
          return false;
        }
        throw error;
      }
      if (!shouldBackupAndReconfigure) {
        console.log(ansis.yellow(`${i18n.t("ccr:keepingExistingConfig")}`));
        await configureCcrProxy(existingConfig);
        return true;
      }
      backupCcrConfig();
    }
    const preset = await selectCcrPreset();
    if (!preset) {
      return false;
    }
    let config;
    if (preset === "skip") {
      console.log(ansis.yellow(`${i18n.t("ccr:skipConfiguring")}`));
      config = createDefaultCcrConfig();
    } else {
      config = await configureCcrWithPreset(preset);
    }
    writeCcrConfig(config);
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrConfigSuccess")}`));
    await configureCcrProxy(config);
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:proxyConfigSuccess")}`));
    await restartAndCheckCcrStatus();
    await showConfigurationTips(config.APIKEY);
    try {
      addCompletedOnboarding();
    } catch (error) {
      console.error(ansis.red(i18n.t("errors:failedToSetOnboarding")), error);
    }
    return true;
  } catch (error) {
    if (error.name === "ExitPromptError") {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return false;
    }
    console.error(ansis.red(`${i18n.t("ccr:ccrConfigFailed")}:`), error);
    return false;
  }
}
async function configureCcrFeature() {
  ensureI18nInitialized();
  const backupDir = backupExistingConfig();
  if (backupDir) {
    console.log(ansis.gray(`\u2714 ${i18n.t("configuration:backupSuccess")}: ${backupDir}`));
  }
  await setupCcrConfiguration();
}

const execAsync$3 = promisify(exec$1);
async function getInstalledVersion(command, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      let stdout;
      try {
        const result = await execAsync$3(`${command} -v`);
        stdout = result.stdout;
      } catch {
        const result = await execAsync$3(`${command} --version`);
        stdout = result.stdout;
      }
      const versionMatch = stdout.match(/(\d+\.\d+\.\d+(?:-[\w.]+)?)/);
      return versionMatch ? versionMatch[1] : null;
    } catch {
      if (attempt === maxRetries) {
        return null;
      }
      await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
    }
  }
  return null;
}
async function getLatestVersion(packageName, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const { stdout } = await execAsync$3(`npm view ${packageName} version`);
      return stdout.trim();
    } catch {
      if (attempt === maxRetries) {
        return null;
      }
      await new Promise((resolve) => setTimeout(resolve, 200 * attempt));
    }
  }
  return null;
}
function compareVersions(current, latest) {
  if (!semver.valid(current) || !semver.valid(latest)) {
    return -1;
  }
  return semver.compare(current, latest);
}
function shouldUpdate(current, latest) {
  return compareVersions(current, latest) < 0;
}
async function checkCcrVersion() {
  const currentVersion = await getInstalledVersion("ccr");
  const latestVersion = await getLatestVersion("@musistudio/claude-code-router");
  return {
    installed: currentVersion !== null,
    currentVersion,
    latestVersion,
    needsUpdate: currentVersion && latestVersion ? shouldUpdate(currentVersion, latestVersion) : false
  };
}
async function checkClaudeCodeVersion() {
  const currentVersion = await getInstalledVersion("claude");
  const latestVersion = await getLatestVersion("@anthropic-ai/claude-code");
  return {
    installed: currentVersion !== null,
    currentVersion,
    latestVersion,
    needsUpdate: currentVersion && latestVersion ? shouldUpdate(currentVersion, latestVersion) : false
  };
}
async function checkCometixLineVersion() {
  const currentVersion = await getInstalledVersion("ccline");
  const latestVersion = await getLatestVersion("@cometix/ccline");
  return {
    installed: currentVersion !== null,
    currentVersion,
    latestVersion,
    needsUpdate: currentVersion && latestVersion ? shouldUpdate(currentVersion, latestVersion) : false
  };
}
async function checkClaudeCodeVersionAndPrompt(skipPrompt = false) {
  try {
    const versionInfo = await checkClaudeCodeVersion();
    if (!versionInfo.needsUpdate) {
      return;
    }
    const { updateClaudeCode } = await Promise.resolve().then(function () { return autoUpdater; });
    const forceUpdate = skipPrompt;
    await updateClaudeCode(forceUpdate);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(`Claude Code version check failed: ${errorMessage}`);
  }
}

const execAsync$2 = promisify(exec$1);
async function updateCcr(force = false) {
  ensureI18nInitialized();
  const spinner = ora(i18n.t("updater:checkingVersion")).start();
  try {
    const { installed, currentVersion, latestVersion, needsUpdate } = await checkCcrVersion();
    spinner.stop();
    if (!installed) {
      console.log(ansis.yellow(i18n.t("updater:ccrNotInstalled")));
      return false;
    }
    if (!needsUpdate && !force) {
      console.log(ansis.green(format(i18n.t("updater:ccrUpToDate"), { version: currentVersion || "" })));
      return true;
    }
    if (!latestVersion) {
      console.log(ansis.yellow(i18n.t("updater:cannotCheckVersion")));
      return false;
    }
    console.log(ansis.cyan(format(i18n.t("updater:currentVersion"), { version: currentVersion || "" })));
    console.log(ansis.cyan(format(i18n.t("updater:latestVersion"), { version: latestVersion })));
    const { confirm } = await inquirer.prompt({
      type: "confirm",
      name: "confirm",
      message: format(i18n.t("updater:confirmUpdate"), { tool: "CCR" }),
      default: true
    });
    if (!confirm) {
      console.log(ansis.gray(i18n.t("updater:updateSkipped")));
      return true;
    }
    const updateSpinner = ora(format(i18n.t("updater:updating"), { tool: "CCR" })).start();
    try {
      await execAsync$2("npm update -g @musistudio/claude-code-router");
      updateSpinner.succeed(format(i18n.t("updater:updateSuccess"), { tool: "CCR" }));
      return true;
    } catch (error) {
      updateSpinner.fail(format(i18n.t("updater:updateFailed"), { tool: "CCR" }));
      console.error(ansis.red(error instanceof Error ? error.message : String(error)));
      return false;
    }
  } catch (error) {
    spinner.fail(i18n.t("updater:checkFailed"));
    console.error(ansis.red(error instanceof Error ? error.message : String(error)));
    return false;
  }
}
async function updateClaudeCode(force = false) {
  ensureI18nInitialized();
  const spinner = ora(i18n.t("updater:checkingVersion")).start();
  try {
    const { installed, currentVersion, latestVersion, needsUpdate } = await checkClaudeCodeVersion();
    spinner.stop();
    if (!installed) {
      console.log(ansis.yellow(i18n.t("updater:claudeCodeNotInstalled")));
      return false;
    }
    if (!needsUpdate && !force) {
      console.log(ansis.green(format(i18n.t("updater:claudeCodeUpToDate"), { version: currentVersion || "" })));
      return true;
    }
    if (!latestVersion) {
      console.log(ansis.yellow(i18n.t("updater:cannotCheckVersion")));
      return false;
    }
    console.log(ansis.cyan(format(i18n.t("updater:currentVersion"), { version: currentVersion || "" })));
    console.log(ansis.cyan(format(i18n.t("updater:latestVersion"), { version: latestVersion })));
    const { confirm } = await inquirer.prompt({
      type: "confirm",
      name: "confirm",
      message: format(i18n.t("updater:confirmUpdate"), { tool: "Claude Code" }),
      default: true
    });
    if (!confirm) {
      console.log(ansis.gray(i18n.t("updater:updateSkipped")));
      return true;
    }
    const updateSpinner = ora(format(i18n.t("updater:updating"), { tool: "Claude Code" })).start();
    try {
      await execAsync$2("npm update -g @anthropic-ai/claude-code");
      updateSpinner.succeed(format(i18n.t("updater:updateSuccess"), { tool: "Claude Code" }));
      return true;
    } catch (error) {
      updateSpinner.fail(format(i18n.t("updater:updateFailed"), { tool: "Claude Code" }));
      console.error(ansis.red(error instanceof Error ? error.message : String(error)));
      return false;
    }
  } catch (error) {
    spinner.fail(i18n.t("updater:checkFailed"));
    console.error(ansis.red(error instanceof Error ? error.message : String(error)));
    return false;
  }
}
async function updateCometixLine(force = false) {
  ensureI18nInitialized();
  const spinner = ora(i18n.t("updater:checkingVersion")).start();
  try {
    const { installed, currentVersion, latestVersion, needsUpdate } = await checkCometixLineVersion();
    spinner.stop();
    if (!installed) {
      console.log(ansis.yellow(i18n.t("updater:cometixLineNotInstalled")));
      return false;
    }
    if (!needsUpdate && !force) {
      console.log(ansis.green(format(i18n.t("updater:cometixLineUpToDate"), { version: currentVersion || "" })));
      return true;
    }
    if (!latestVersion) {
      console.log(ansis.yellow(i18n.t("updater:cannotCheckVersion")));
      return false;
    }
    console.log(ansis.cyan(format(i18n.t("updater:currentVersion"), { version: currentVersion || "" })));
    console.log(ansis.cyan(format(i18n.t("updater:latestVersion"), { version: latestVersion })));
    const { confirm } = await inquirer.prompt({
      type: "confirm",
      name: "confirm",
      message: format(i18n.t("updater:confirmUpdate"), { tool: "CCometixLine" }),
      default: true
    });
    if (!confirm) {
      console.log(ansis.gray(i18n.t("updater:updateSkipped")));
      return true;
    }
    const updateSpinner = ora(format(i18n.t("updater:updating"), { tool: "CCometixLine" })).start();
    try {
      await execAsync$2("npm update -g @cometix/ccline");
      updateSpinner.succeed(format(i18n.t("updater:updateSuccess"), { tool: "CCometixLine" }));
      return true;
    } catch (error) {
      updateSpinner.fail(format(i18n.t("updater:updateFailed"), { tool: "CCometixLine" }));
      console.error(ansis.red(error instanceof Error ? error.message : String(error)));
      return false;
    }
  } catch (error) {
    spinner.fail(i18n.t("updater:checkFailed"));
    console.error(ansis.red(error instanceof Error ? error.message : String(error)));
    return false;
  }
}
async function checkAndUpdateTools() {
  ensureI18nInitialized();
  console.log(ansis.bold.cyan(`
\u{1F50D} ${i18n.t("updater:checkingTools")}
`));
  await updateCcr();
  console.log();
  await updateClaudeCode();
  console.log();
  await updateCometixLine();
}

const autoUpdater = {
  __proto__: null,
  checkAndUpdateTools: checkAndUpdateTools,
  updateCcr: updateCcr,
  updateClaudeCode: updateClaudeCode,
  updateCometixLine: updateCometixLine
};

const execAsync$1 = promisify(exec$1);
async function isCcrInstalled() {
  let commandExists = false;
  try {
    await execAsync$1("ccr version");
    commandExists = true;
  } catch {
    try {
      await execAsync$1("which ccr");
      commandExists = true;
    } catch {
      commandExists = false;
    }
  }
  let hasCorrectPackage = false;
  try {
    await execAsync$1("npm list -g @musistudio/claude-code-router");
    hasCorrectPackage = true;
  } catch {
    hasCorrectPackage = false;
  }
  return {
    isInstalled: commandExists,
    hasCorrectPackage
  };
}
async function installCcr() {
  ensureI18nInitialized();
  const { isInstalled, hasCorrectPackage } = await isCcrInstalled();
  if (hasCorrectPackage) {
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
    await updateCcr();
    return;
  }
  if (isInstalled && !hasCorrectPackage) {
    try {
      await execAsync$1("npm list -g claude-code-router");
      console.log(ansis.yellow(`\u26A0 ${i18n.t("ccr:detectedIncorrectPackage")}`));
      try {
        await execAsync$1("npm uninstall -g claude-code-router");
        console.log(ansis.green(`\u2714 ${i18n.t("ccr:uninstalledIncorrectPackage")}`));
      } catch {
        console.log(ansis.yellow(`\u26A0 ${i18n.t("ccr:failedToUninstallIncorrectPackage")}`));
      }
    } catch {
    }
  }
  console.log(ansis.cyan(`\u{1F4E6} ${i18n.t("ccr:installingCcr")}`));
  try {
    await execAsync$1("npm install -g @musistudio/claude-code-router --force");
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrInstallSuccess")}`));
  } catch (error) {
    if (error.message?.includes("EEXIST")) {
      console.log(ansis.yellow(`\u26A0 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
      await updateCcr();
      return;
    }
    console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrInstallFailed")}`));
    throw error;
  }
}

function getPlatformStatusLineConfig() {
  return {
    type: "command",
    command: isWindows() ? "%USERPROFILE%\\.claude\\ccline\\ccline.exe" : "~/.claude/ccline/ccline",
    padding: 0
  };
}

function addCCometixLineConfig() {
  try {
    const statusLineConfig = getPlatformStatusLineConfig();
    let settings = {};
    if (exists(SETTINGS_FILE)) {
      settings = readJsonConfig(SETTINGS_FILE) || {};
    }
    settings.statusLine = statusLineConfig;
    writeJsonConfig(SETTINGS_FILE, settings);
    return true;
  } catch (error) {
    console.error("Failed to add CCometixLine configuration:", error);
    return false;
  }
}
function hasCCometixLineConfig() {
  try {
    if (!exists(SETTINGS_FILE)) {
      return false;
    }
    const settings = readJsonConfig(SETTINGS_FILE);
    return !!settings?.statusLine?.command?.includes("ccline");
  } catch {
    return false;
  }
}

const COMETIX_PACKAGE_NAME = "@cometix/ccline";
const COMETIX_COMMAND_NAME = "ccline";
const COMETIX_COMMANDS = {
  CHECK_INSTALL: `npm list -g ${COMETIX_PACKAGE_NAME}`,
  INSTALL: `npm install -g ${COMETIX_PACKAGE_NAME}`,
  UPDATE: `npm update -g ${COMETIX_PACKAGE_NAME}`,
  PRINT_CONFIG: `${COMETIX_COMMAND_NAME} --print`,
  TUI_CONFIG: `${COMETIX_COMMAND_NAME} -c`
};

const execAsync = promisify(exec$1);
async function isCometixLineInstalled() {
  try {
    await execAsync(COMETIX_COMMANDS.CHECK_INSTALL);
    return true;
  } catch {
    return false;
  }
}
async function installCometixLine() {
  ensureI18nInitialized();
  const isInstalled = await isCometixLineInstalled();
  if (isInstalled) {
    console.log(ansis.green(`\u2714 ${i18n.t("cometix:cometixAlreadyInstalled")}`));
    try {
      console.log(ansis.blue(`${i18n.t("cometix:installingOrUpdating")}`));
      await execAsync(COMETIX_COMMANDS.INSTALL);
      console.log(ansis.green(`\u2714 ${i18n.t("cometix:installUpdateSuccess")}`));
    } catch (error) {
      console.log(ansis.yellow(`\u26A0 ${i18n.t("cometix:installUpdateFailed")}: ${error}`));
    }
    if (!hasCCometixLineConfig()) {
      try {
        addCCometixLineConfig();
        console.log(ansis.green(`\u2714 ${i18n.t("cometix:statusLineConfigured") || "Claude Code statusLine configured"}`));
      } catch (error) {
        console.log(ansis.yellow(`\u26A0 ${i18n.t("cometix:statusLineConfigFailed") || "Failed to configure statusLine"}: ${error}`));
      }
    } else {
      console.log(ansis.blue(`\u2139 ${i18n.t("cometix:statusLineAlreadyConfigured") || "Claude Code statusLine already configured"}`));
    }
    return;
  }
  try {
    console.log(ansis.blue(`${i18n.t("cometix:installingCometix")}`));
    await execAsync(COMETIX_COMMANDS.INSTALL);
    console.log(ansis.green(`\u2714 ${i18n.t("cometix:cometixInstallSuccess")}`));
    try {
      addCCometixLineConfig();
      console.log(ansis.green(`\u2714 ${i18n.t("cometix:statusLineConfigured") || "Claude Code statusLine configured"}`));
    } catch (configError) {
      console.log(ansis.yellow(`\u26A0 ${i18n.t("cometix:statusLineConfigFailed") || "Failed to configure statusLine"}: ${configError}`));
      console.log(ansis.blue(`\u{1F4A1} ${i18n.t("cometix:statusLineManualConfig") || "Please manually add statusLine configuration to Claude Code settings"}`));
    }
  } catch (error) {
    console.error(ansis.red(`\u2717 ${i18n.t("cometix:cometixInstallFailed")}: ${error}`));
    throw error;
  }
}

function addNumbersToChoices(choices, startFrom = 1, format = (n) => `${n}. `) {
  let currentNumber = startFrom;
  return choices.map((choice) => {
    if (choice.disabled) {
      return choice;
    }
    const numbered = {
      ...choice,
      name: `${format(currentNumber)}${choice.name}`
    };
    currentNumber++;
    return numbered;
  });
}

function readZcfConfig() {
  let config = readJsonConfig(ZCF_CONFIG_FILE);
  if (!config && existsSync(LEGACY_ZCF_CONFIG_FILE)) {
    config = readJsonConfig(LEGACY_ZCF_CONFIG_FILE);
  }
  return config;
}
async function readZcfConfigAsync() {
  return readZcfConfig();
}
function writeZcfConfig(config) {
  try {
    writeJsonConfig(ZCF_CONFIG_FILE, config);
  } catch {
  }
}
function updateZcfConfig(updates) {
  const existingConfig = readZcfConfig();
  const newConfig = {
    version: updates.version || existingConfig?.version || "1.0.0",
    preferredLang: updates.preferredLang || existingConfig?.preferredLang || "en",
    aiOutputLang: updates.aiOutputLang || existingConfig?.aiOutputLang,
    outputStyles: updates.outputStyles !== void 0 ? updates.outputStyles : existingConfig?.outputStyles,
    defaultOutputStyle: updates.defaultOutputStyle !== void 0 ? updates.defaultOutputStyle : existingConfig?.defaultOutputStyle,
    lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
  };
  writeZcfConfig(newConfig);
}

const OUTPUT_STYLES = [
  // Custom styles (have template files)
  {
    id: "engineer-professional",
    isCustom: true,
    filePath: "engineer-professional.md"
  },
  {
    id: "nekomata-engineer",
    isCustom: true,
    filePath: "nekomata-engineer.md"
  },
  {
    id: "laowang-engineer",
    isCustom: true,
    filePath: "laowang-engineer.md"
  },
  // Built-in styles (no template files)
  {
    id: "default",
    isCustom: false
  },
  {
    id: "explanatory",
    isCustom: false
  },
  {
    id: "learning",
    isCustom: false
  }
];
const LEGACY_FILES = ["personality.md", "rules.md", "technical-guides.md", "mcp.md", "language.md"];
function getAvailableOutputStyles() {
  return OUTPUT_STYLES;
}
async function copyOutputStyles(selectedStyles, lang) {
  const outputStylesDir = join(CLAUDE_DIR, "output-styles");
  ensureDir(outputStylesDir);
  const currentFilePath = fileURLToPath(import.meta.url);
  const distDir = dirname(dirname(currentFilePath));
  const rootDir = dirname(distDir);
  const templateDir = join(rootDir, "templates", lang, "output-styles");
  for (const styleId of selectedStyles) {
    const style = OUTPUT_STYLES.find((s) => s.id === styleId);
    if (!style || !style.isCustom || !style.filePath) {
      continue;
    }
    const sourcePath = join(templateDir, style.filePath);
    const destPath = join(outputStylesDir, style.filePath);
    if (exists(sourcePath)) {
      copyFile(sourcePath, destPath);
    }
  }
}
function setGlobalDefaultOutputStyle(styleId) {
  const existingSettings = readJsonConfig(SETTINGS_FILE) || {};
  const updatedSettings = {
    ...existingSettings,
    outputStyle: styleId
  };
  writeJsonConfig(SETTINGS_FILE, updatedSettings);
}
function hasLegacyPersonalityFiles() {
  return LEGACY_FILES.some((filename) => exists(join(CLAUDE_DIR, filename)));
}
function cleanupLegacyPersonalityFiles() {
  LEGACY_FILES.forEach((filename) => {
    const filePath = join(CLAUDE_DIR, filename);
    if (exists(filePath)) {
      removeFile(filePath);
    }
  });
}
async function configureOutputStyle(preselectedStyles, preselectedDefault) {
  ensureI18nInitialized();
  const outputStyleList = [
    {
      id: "default",
      name: i18n.t("configuration:outputStyles.default.name"),
      description: i18n.t("configuration:outputStyles.default.description")
    },
    {
      id: "engineer-professional",
      name: i18n.t("configuration:outputStyles.engineer-professional.name"),
      description: i18n.t("configuration:outputStyles.engineer-professional.description")
    },
    {
      id: "explanatory",
      name: i18n.t("configuration:outputStyles.explanatory.name"),
      description: i18n.t("configuration:outputStyles.explanatory.description")
    },
    {
      id: "laowang-engineer",
      name: i18n.t("configuration:outputStyles.laowang-engineer.name"),
      description: i18n.t("configuration:outputStyles.laowang-engineer.description")
    },
    {
      id: "learning",
      name: i18n.t("configuration:outputStyles.learning.name"),
      description: i18n.t("configuration:outputStyles.learning.description")
    },
    {
      id: "nekomata-engineer",
      name: i18n.t("configuration:outputStyles.nekomata-engineer.name"),
      description: i18n.t("configuration:outputStyles.nekomata-engineer.description")
    }
  ];
  const availableStyles = getAvailableOutputStyles();
  if (hasLegacyPersonalityFiles() && !preselectedStyles) {
    console.log(ansis.yellow(`\u26A0\uFE0F  ${i18n.t("configuration:legacyFilesDetected")}`));
    const { cleanupLegacy } = await inquirer.prompt({
      type: "confirm",
      name: "cleanupLegacy",
      message: i18n.t("configuration:cleanupLegacyFiles"),
      default: true
    });
    if (cleanupLegacy) {
      cleanupLegacyPersonalityFiles();
      console.log(ansis.green(`\u2714 ${i18n.t("configuration:legacyFilesRemoved")}`));
    }
  } else if (hasLegacyPersonalityFiles() && preselectedStyles) {
    cleanupLegacyPersonalityFiles();
  }
  let selectedStyles;
  let defaultStyle;
  if (preselectedStyles && preselectedDefault) {
    selectedStyles = preselectedStyles;
    defaultStyle = preselectedDefault;
  } else {
    const customStyles = availableStyles.filter((style) => style.isCustom);
    const { selectedStyles: promptedStyles } = await inquirer.prompt({
      type: "checkbox",
      name: "selectedStyles",
      message: `${i18n.t("configuration:selectOutputStyles")}${i18n.t("common:multiSelectHint")}`,
      choices: addNumbersToChoices(customStyles.map((style) => {
        const styleInfo = outputStyleList.find((s) => s.id === style.id);
        return {
          name: `${styleInfo?.name || style.id} - ${ansis.gray(styleInfo?.description || "")}`,
          value: style.id,
          checked: true
          // Default select all custom styles
        };
      })),
      validate: async (input) => input.length > 0 || i18n.t("configuration:selectAtLeastOne")
    });
    if (!promptedStyles || promptedStyles.length === 0) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return;
    }
    selectedStyles = promptedStyles;
    const { defaultStyle: promptedDefault } = await inquirer.prompt({
      type: "list",
      name: "defaultStyle",
      message: i18n.t("configuration:selectDefaultOutputStyle"),
      choices: addNumbersToChoices([
        // Show selected custom styles first (only what user actually installed)
        ...selectedStyles.map((styleId) => {
          const styleInfo = outputStyleList.find((s) => s.id === styleId);
          return {
            name: `${styleInfo?.name || styleId} - ${ansis.gray(styleInfo?.description || "")}`,
            value: styleId,
            short: styleInfo?.name || styleId
          };
        }),
        // Then show all built-in styles (always available)
        ...availableStyles.filter((style) => !style.isCustom).map((style) => {
          const styleInfo = outputStyleList.find((s) => s.id === style.id);
          return {
            name: `${styleInfo?.name || style.id} - ${ansis.gray(styleInfo?.description || "")}`,
            value: style.id,
            short: styleInfo?.name || style.id
          };
        })
      ]),
      default: selectedStyles.includes("engineer-professional") ? "engineer-professional" : selectedStyles[0]
    });
    if (!promptedDefault) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return;
    }
    defaultStyle = promptedDefault;
  }
  await copyOutputStyles(selectedStyles, "zh-CN");
  setGlobalDefaultOutputStyle(defaultStyle);
  updateZcfConfig({
    outputStyles: selectedStyles,
    defaultOutputStyle: defaultStyle
  });
  console.log(ansis.green(`\u2714 ${i18n.t("configuration:outputStyleInstalled")}`));
  console.log(ansis.gray(`  ${i18n.t("configuration:selectedStyles")}: ${selectedStyles.join(", ")}`));
  console.log(ansis.gray(`  ${i18n.t("configuration:defaultStyle")}: ${defaultStyle}`));
}

function validateApiKey(apiKey) {
  if (!apiKey || apiKey.trim() === "") {
    return {
      isValid: false,
      // Note: This should use i18next, but due to sync constraint in inquirer validate,
      // we temporarily use a generic message. This will be fixed when we refactor to async validation.
      error: "API key cannot be empty"
    };
  }
  return { isValid: true };
}
function formatApiKeyDisplay(apiKey) {
  if (!apiKey || apiKey.length < 12) {
    return apiKey;
  }
  return `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}`;
}

async function configureApiCompletely(preselectedAuthType) {
  ensureI18nInitialized();
  let authType = preselectedAuthType;
  if (!authType) {
    const { authType: selectedAuthType } = await inquirer.prompt({
      type: "list",
      name: "authType",
      message: i18n.t("api:configureApi"),
      choices: addNumbersToChoices([
        {
          name: `${i18n.t("api:useAuthToken")} - ${ansis.gray(i18n.t("api:authTokenDesc"))}`,
          value: "auth_token",
          short: i18n.t("api:useAuthToken")
        },
        {
          name: `${i18n.t("api:useApiKey")} - ${ansis.gray(i18n.t("api:apiKeyDesc"))}`,
          value: "api_key",
          short: i18n.t("api:useApiKey")
        }
      ])
    });
    if (!selectedAuthType) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return null;
    }
    authType = selectedAuthType;
  }
  const { url } = await inquirer.prompt({
    type: "input",
    name: "url",
    message: i18n.t("api:enterApiUrl"),
    validate: async (value) => {
      if (!value)
        return i18n.t("api:urlRequired");
      try {
        void new URL(value);
        return true;
      } catch {
        return i18n.t("api:invalidUrl");
      }
    }
  });
  if (url === void 0) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    return null;
  }
  const keyMessage = authType === "auth_token" ? i18n.t("api:enterAuthToken") : i18n.t("api:enterApiKey");
  const { key } = await inquirer.prompt({
    type: "input",
    name: "key",
    message: keyMessage,
    validate: async (value) => {
      if (!value) {
        return i18n.t("api:keyRequired");
      }
      const validation = validateApiKey(value);
      if (!validation.isValid) {
        return validation.error || i18n.t("api:invalidKeyFormat");
      }
      return true;
    }
  });
  if (key === void 0) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    return null;
  }
  console.log(ansis.gray(`  API Key: ${formatApiKeyDisplay(key)}`));
  return { url, key, authType };
}
async function modifyApiConfigPartially(existingConfig) {
  ensureI18nInitialized();
  let currentConfig = { ...existingConfig };
  const latestConfig = getExistingApiConfig();
  if (latestConfig) {
    currentConfig = latestConfig;
  }
  const { item } = await inquirer.prompt({
    type: "list",
    name: "item",
    message: i18n.t("api:selectModifyItems"),
    choices: addNumbersToChoices([
      { name: i18n.t("api:modifyApiUrl"), value: "url" },
      { name: i18n.t("api:modifyApiKey"), value: "key" },
      { name: i18n.t("api:modifyAuthType"), value: "authType" }
    ])
  });
  if (!item) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    return;
  }
  if (item === "url") {
    const { url } = await inquirer.prompt({
      type: "input",
      name: "url",
      message: i18n.t("api:enterNewApiUrl").replace("{url}", currentConfig.url || i18n.t("common:none")),
      default: currentConfig.url,
      validate: async (value) => {
        if (!value)
          return i18n.t("api:urlRequired");
        try {
          void new URL(value);
          return true;
        } catch {
          return i18n.t("api:invalidUrl");
        }
      }
    });
    if (url === void 0) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return;
    }
    currentConfig.url = url;
    const savedConfig = configureApi(currentConfig);
    if (savedConfig) {
      console.log(ansis.green(`\u2714 ${i18n.t("api:modificationSaved")}`));
      console.log(ansis.gray(`  ${i18n.t("api:apiConfigUrl")}: ${savedConfig.url}`));
    }
  } else if (item === "key") {
    const authType = currentConfig.authType || "auth_token";
    const keyMessage = authType === "auth_token" ? i18n.t("api:enterNewApiKey").replace("{key}", currentConfig.key ? formatApiKeyDisplay(currentConfig.key) : i18n.t("common:none")) : i18n.t("api:enterNewApiKey").replace("{key}", currentConfig.key ? formatApiKeyDisplay(currentConfig.key) : i18n.t("common:none"));
    const { key } = await inquirer.prompt({
      type: "input",
      name: "key",
      message: keyMessage,
      validate: async (value) => {
        if (!value) {
          return i18n.t("api:keyRequired");
        }
        const validation = validateApiKey(value);
        if (!validation.isValid) {
          return validation.error || i18n.t("api:invalidKeyFormat");
        }
        return true;
      }
    });
    if (key === void 0) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return;
    }
    currentConfig.key = key;
    const savedConfig = configureApi(currentConfig);
    if (savedConfig) {
      console.log(ansis.green(`\u2714 ${i18n.t("api:modificationSaved")}`));
      console.log(ansis.gray(`  ${i18n.t("api:apiConfigKey")}: ${formatApiKeyDisplay(savedConfig.key)}`));
    }
  } else if (item === "authType") {
    const { authType } = await inquirer.prompt({
      type: "list",
      name: "authType",
      message: i18n.t("api:selectNewAuthType").replace("{type}", currentConfig.authType || i18n.t("common:none")),
      choices: addNumbersToChoices([
        { name: "Auth Token (OAuth)", value: "auth_token" },
        { name: "API Key", value: "api_key" }
      ]),
      default: currentConfig.authType === "api_key" ? 1 : 0
    });
    if (authType === void 0) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      return;
    }
    currentConfig.authType = authType;
    const savedConfig = configureApi(currentConfig);
    if (savedConfig) {
      console.log(ansis.green(`\u2714 ${i18n.t("api:modificationSaved")}`));
      console.log(ansis.gray(`  ${i18n.t("api:apiConfigAuthType")}: ${savedConfig.authType}`));
    }
  }
}
async function updatePromptOnly(aiOutputLang) {
  ensureI18nInitialized();
  const backupDir = backupExistingConfig();
  if (backupDir) {
    console.log(ansis.gray(`\u2714 ${i18n.t("configuration:backupSuccess")}: ${backupDir}`));
  }
  if (aiOutputLang) {
    applyAiLanguageDirective(aiOutputLang);
  }
  await configureOutputStyle();
  console.log(ansis.green(`\u2714 ${i18n.t("configuration:configSuccess")} ${CLAUDE_DIR}`));
  console.log(`
${ansis.cyan(i18n.t("common:complete"))}`);
}

function handleExitPromptError(error) {
  if (error instanceof Error && error.name === "ExitPromptError") {
    console.log(ansis.cyan(`
${i18n.t("common:goodbye")}
`));
    process.exit(0);
  }
  return false;
}
function handleGeneralError(error) {
  console.error(ansis.red("Error:"), error);
  if (error instanceof Error) {
    console.error(ansis.gray(`Stack: ${error.stack}`));
  }
  process.exit(1);
}

async function isClaudeCodeInstalled() {
  return await commandExists("claude");
}
async function installClaudeCode() {
  ensureI18nInitialized();
  const installed = await isClaudeCodeInstalled();
  if (installed) {
    console.log(ansis.green(`\u2714 ${i18n.t("installation:alreadyInstalled")}`));
    await updateClaudeCode();
    return;
  }
  if (isTermux()) {
    console.log(ansis.yellow(`\u2139 ${i18n.t("installation:termuxDetected")}`));
    const termuxPrefix = getTermuxPrefix();
    console.log(ansis.gray(i18n.t("installation:termuxPathInfo", { path: termuxPrefix })));
    console.log(ansis.gray(`Node.js: ${termuxPrefix}/bin/node`));
    console.log(ansis.gray(`npm: ${termuxPrefix}/bin/npm`));
  }
  console.log(i18n.t("installation:installing"));
  try {
    await exec("npm", ["install", "-g", "@anthropic-ai/claude-code"]);
    console.log(`\u2714 ${i18n.t("installation:installSuccess")}`);
    if (isTermux()) {
      console.log(ansis.gray(`
Claude Code installed to: ${getTermuxPrefix()}/bin/claude`));
    }
  } catch (error) {
    console.error(`\u2716 ${i18n.t("installation:installFailed")}`);
    if (isTermux()) {
      console.error(ansis.yellow(`
${i18n.t("installation:termuxInstallHint")}
`));
    }
    throw error;
  }
}

async function selectMcpServices() {
  ensureI18nInitialized();
  const mcpServices = await getMcpServices();
  const choices = mcpServices.map((service) => ({
    name: `${service.name} - ${ansis.gray(service.description)}`,
    value: service.id,
    selected: false
  }));
  const { services } = await inquirer.prompt({
    type: "checkbox",
    name: "services",
    message: `${i18n.t("mcp:selectMcpServices")}${i18n.t("common:multiSelectHint")}`,
    choices
  });
  if (services === void 0) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    return void 0;
  }
  return services;
}

async function selectAiOutputLanguage(defaultLang) {
  ensureI18nInitialized();
  console.log(ansis.dim(`
  ${i18n.t("language:aiOutputLangHint")}
`));
  const aiLangChoices = Object.entries(AI_OUTPUT_LANGUAGES).map(([key]) => ({
    title: getAiOutputLanguageLabel(key),
    value: key
  }));
  const defaultChoice = defaultLang || "en";
  const { lang } = await inquirer.prompt({
    type: "list",
    name: "lang",
    message: i18n.t("language:selectAiOutputLang"),
    choices: addNumbersToChoices(aiLangChoices.map((choice) => ({
      name: choice.title,
      value: choice.value
    }))),
    default: defaultChoice
  });
  if (!lang) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    process.exit(0);
  }
  const aiOutputLang = lang;
  if (aiOutputLang === "custom") {
    const { customLang } = await inquirer.prompt({
      type: "input",
      name: "customLang",
      message: i18n.t("language:enterCustomLanguage"),
      validate: async (value) => !!value || i18n.t("language:languageRequired") || "Language is required"
    });
    if (!customLang) {
      console.log(ansis.yellow(i18n.t("common:cancelled")));
      process.exit(0);
    }
    return customLang;
  }
  return aiOutputLang;
}
const LANGUAGE_SELECTION_MESSAGES = {
  selectLanguage: "Select ZCF display language / \u9009\u62E9ZCF\u663E\u793A\u8BED\u8A00",
  operationCancelled: "Operation cancelled / \u64CD\u4F5C\u5DF2\u53D6\u6D88"
};
async function selectScriptLanguage(currentLang) {
  const zcfConfig = readZcfConfig();
  if (zcfConfig?.preferredLang) {
    return zcfConfig.preferredLang;
  }
  const { lang } = await inquirer.prompt({
    type: "list",
    name: "lang",
    message: LANGUAGE_SELECTION_MESSAGES.selectLanguage,
    choices: addNumbersToChoices(SUPPORTED_LANGS.map((l) => ({
      name: LANG_LABELS[l],
      value: l
    })))
  });
  if (!lang) {
    console.log(ansis.yellow(LANGUAGE_SELECTION_MESSAGES.operationCancelled));
    process.exit(0);
  }
  const scriptLang = lang;
  updateZcfConfig({
    version,
    preferredLang: scriptLang
  });
  return scriptLang;
}
async function resolveAiOutputLanguage(scriptLang, commandLineOption, savedConfig) {
  ensureI18nInitialized();
  if (commandLineOption) {
    return commandLineOption;
  }
  if (savedConfig?.aiOutputLang) {
    console.log(ansis.gray(`\u2714 ${i18n.t("language:aiOutputLangHint")}: ${savedConfig.aiOutputLang}`));
    return savedConfig.aiOutputLang;
  }
  return await selectAiOutputLanguage(scriptLang);
}

const prompts = {
  __proto__: null,
  resolveAiOutputLanguage: resolveAiOutputLanguage,
  selectAiOutputLanguage: selectAiOutputLanguage,
  selectScriptLanguage: selectScriptLanguage
};

function getRootDir() {
  const currentFilePath = fileURLToPath(import.meta.url);
  const distDir = dirname(dirname(currentFilePath));
  return dirname(distDir);
}
async function selectAndInstallWorkflows(configLang, preselectedWorkflows) {
  ensureI18nInitialized();
  const workflows = getOrderedWorkflows();
  const choices = workflows.map((workflow) => {
    return {
      name: workflow.name,
      value: workflow.id,
      checked: workflow.defaultSelected
    };
  });
  let selectedWorkflows;
  if (preselectedWorkflows) {
    selectedWorkflows = preselectedWorkflows;
  } else {
    const response = await inquirer.prompt({
      type: "checkbox",
      name: "selectedWorkflows",
      message: `${i18n.t("workflow:selectWorkflowType")}${i18n.t("common:multiSelectHint")}`,
      choices
    });
    selectedWorkflows = response.selectedWorkflows;
  }
  if (!selectedWorkflows || selectedWorkflows.length === 0) {
    console.log(ansis.yellow(i18n.t("common:cancelled")));
    return;
  }
  await cleanupOldVersionFiles();
  for (const workflowId of selectedWorkflows) {
    const config = getWorkflowConfig(workflowId);
    if (config) {
      await installWorkflowWithDependencies(config, configLang);
    }
  }
}
async function installWorkflowWithDependencies(config, configLang) {
  const rootDir = getRootDir();
  ensureI18nInitialized();
  const result = {
    workflow: config.id,
    success: true,
    installedCommands: [],
    installedAgents: [],
    errors: []
  };
  const WORKFLOW_OPTION_KEYS = {
    commonTools: i18n.t("workflow:workflowOption.commonTools"),
    sixStepsWorkflow: i18n.t("workflow:workflowOption.sixStepsWorkflow"),
    featPlanUx: i18n.t("workflow:workflowOption.featPlanUx"),
    gitWorkflow: i18n.t("workflow:workflowOption.gitWorkflow"),
    bmadWorkflow: i18n.t("workflow:workflowOption.bmadWorkflow")
  };
  const workflowName = WORKFLOW_OPTION_KEYS[config.id] || config.id;
  console.log(ansis.cyan(`
\u{1F4E6} ${i18n.t("workflow:installingWorkflow")}: ${workflowName}...`));
  const commandsDir = join(CLAUDE_DIR, "commands", "zcf");
  if (!existsSync(commandsDir)) {
    await mkdir(commandsDir, { recursive: true });
  }
  for (const commandFile of config.commands) {
    const commandSource = join(rootDir, "templates", configLang, "workflow", config.category, "commands", commandFile);
    const destFileName = commandFile;
    const commandDest = join(commandsDir, destFileName);
    if (existsSync(commandSource)) {
      try {
        await copyFile$1(commandSource, commandDest);
        result.installedCommands.push(destFileName);
        console.log(ansis.gray(`  \u2714 ${i18n.t("workflow:installedCommand")}: zcf/${destFileName}`));
      } catch (error) {
        const errorMsg = `${i18n.t("workflow:failedToInstallCommand")} ${commandFile}: ${error}`;
        result.errors?.push(errorMsg);
        console.error(ansis.red(`  \u2717 ${errorMsg}`));
        result.success = false;
      }
    }
  }
  if (config.autoInstallAgents && config.agents.length > 0) {
    const agentsCategoryDir = join(CLAUDE_DIR, "agents", "zcf", config.category);
    if (!existsSync(agentsCategoryDir)) {
      await mkdir(agentsCategoryDir, { recursive: true });
    }
    for (const agent of config.agents) {
      const agentSource = join(rootDir, "templates", configLang, "workflow", config.category, "agents", agent.filename);
      const agentDest = join(agentsCategoryDir, agent.filename);
      if (existsSync(agentSource)) {
        try {
          await copyFile$1(agentSource, agentDest);
          result.installedAgents.push(agent.filename);
          console.log(ansis.gray(`  \u2714 ${i18n.t("workflow:installedAgent")}: zcf/${config.category}/${agent.filename}`));
        } catch (error) {
          const errorMsg = `${i18n.t("workflow:failedToInstallAgent")} ${agent.filename}: ${error}`;
          result.errors?.push(errorMsg);
          console.error(ansis.red(`  \u2717 ${errorMsg}`));
          if (agent.required) {
            result.success = false;
          }
        }
      }
    }
  }
  if (result.success) {
    console.log(ansis.green(`\u2714 ${workflowName} ${i18n.t("workflow:workflowInstallSuccess")}`));
    if (config.id === "bmadWorkflow") {
      console.log(ansis.cyan(`
${i18n.t("workflow:bmadInitPrompt")}`));
    }
  } else {
    console.log(ansis.red(`\u2717 ${workflowName} ${i18n.t("workflow:workflowInstallError")}`));
  }
  return result;
}
async function cleanupOldVersionFiles() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u{1F9F9} ${i18n.t("workflow:cleaningOldFiles")}...`));
  const oldCommandFiles = [
    join(CLAUDE_DIR, "commands", "workflow.md"),
    join(CLAUDE_DIR, "commands", "feat.md")
  ];
  const oldAgentFiles = [
    join(CLAUDE_DIR, "agents", "planner.md"),
    join(CLAUDE_DIR, "agents", "ui-ux-designer.md")
  ];
  for (const file of oldCommandFiles) {
    if (existsSync(file)) {
      try {
        await rm(file, { force: true });
        console.log(ansis.gray(`  \u2714 ${i18n.t("workflow:removedOldFile")}: ${file.replace(CLAUDE_DIR, "~/.claude")}`));
      } catch {
        console.error(ansis.yellow(`  \u26A0 ${i18n.t("errors:failedToRemoveFile")}: ${file.replace(CLAUDE_DIR, "~/.claude")}`));
      }
    }
  }
  for (const file of oldAgentFiles) {
    if (existsSync(file)) {
      try {
        await rm(file, { force: true });
        console.log(ansis.gray(`  \u2714 ${i18n.t("workflow:removedOldFile")}: ${file.replace(CLAUDE_DIR, "~/.claude")}`));
      } catch {
        console.error(ansis.yellow(`  \u26A0 ${i18n.t("errors:failedToRemoveFile")}: ${file.replace(CLAUDE_DIR, "~/.claude")}`));
      }
    }
  }
}

function validateSkipPromptOptions(options) {
  if (options.allLang) {
    if (options.allLang === "zh-CN" || options.allLang === "en") {
      options.configLang = options.allLang;
      options.aiOutputLang = options.allLang;
    } else {
      options.configLang = "en";
      options.aiOutputLang = options.allLang;
    }
  }
  if (!options.configAction) {
    options.configAction = "backup";
  }
  if (!options.configLang) {
    options.configLang = "en";
  }
  if (!options.aiOutputLang) {
    options.aiOutputLang = "en";
  }
  if (typeof options.outputStyles === "string") {
    if (options.outputStyles === "skip") {
      options.outputStyles = false;
    } else if (options.outputStyles === "all") {
      options.outputStyles = ["engineer-professional", "nekomata-engineer", "laowang-engineer"];
    } else {
      options.outputStyles = options.outputStyles.split(",").map((s) => s.trim());
    }
  }
  if (options.outputStyles === void 0) {
    options.outputStyles = ["engineer-professional", "nekomata-engineer", "laowang-engineer"];
  }
  if (!options.defaultOutputStyle) {
    options.defaultOutputStyle = "engineer-professional";
  }
  if (typeof options.installCometixLine === "string") {
    options.installCometixLine = options.installCometixLine.toLowerCase() === "true";
  }
  if (options.installCometixLine === void 0) {
    options.installCometixLine = true;
  }
  if (options.configAction && !["new", "backup", "merge", "docs-only", "skip"].includes(options.configAction)) {
    throw new Error(
      i18n.t("errors:invalidConfigAction", { value: options.configAction })
    );
  }
  if (options.apiType && !["auth_token", "api_key", "ccr_proxy", "skip"].includes(options.apiType)) {
    throw new Error(
      i18n.t("errors:invalidApiType", { value: options.apiType })
    );
  }
  if (options.apiType === "api_key" && !options.apiKey) {
    throw new Error(i18n.t("errors:apiKeyRequiredForApiKey"));
  }
  if (options.apiType === "auth_token" && !options.apiKey) {
    throw new Error(i18n.t("errors:apiKeyRequiredForAuthToken"));
  }
  if (typeof options.mcpServices === "string") {
    if (options.mcpServices === "skip") {
      options.mcpServices = false;
    } else if (options.mcpServices === "all") {
      options.mcpServices = MCP_SERVICE_CONFIGS.filter((s) => !s.requiresApiKey).map((s) => s.id);
    } else {
      options.mcpServices = options.mcpServices.split(",").map((s) => s.trim());
    }
  }
  if (Array.isArray(options.mcpServices)) {
    const validServices = MCP_SERVICE_CONFIGS.map((s) => s.id);
    for (const service of options.mcpServices) {
      if (!validServices.includes(service)) {
        throw new Error(i18n.t("errors:invalidMcpService", { service, validServices: validServices.join(", ") }));
      }
    }
  }
  if (Array.isArray(options.outputStyles)) {
    const validStyles = ["engineer-professional", "nekomata-engineer", "laowang-engineer", "default", "explanatory", "learning"];
    for (const style of options.outputStyles) {
      if (!validStyles.includes(style)) {
        throw new Error(i18n.t("errors:invalidOutputStyle", { style, validStyles: validStyles.join(", ") }));
      }
    }
  }
  if (options.defaultOutputStyle) {
    const validStyles = ["engineer-professional", "nekomata-engineer", "laowang-engineer", "default", "explanatory", "learning"];
    if (!validStyles.includes(options.defaultOutputStyle)) {
      throw new Error(i18n.t("errors:invalidDefaultOutputStyle", { style: options.defaultOutputStyle, validStyles: validStyles.join(", ") }));
    }
  }
  if (typeof options.workflows === "string") {
    if (options.workflows === "skip") {
      options.workflows = false;
    } else if (options.workflows === "all") {
      options.workflows = WORKFLOW_CONFIG_BASE.map((w) => w.id);
    } else {
      options.workflows = options.workflows.split(",").map((s) => s.trim());
    }
  }
  if (Array.isArray(options.workflows)) {
    const validWorkflows = WORKFLOW_CONFIG_BASE.map((w) => w.id);
    for (const workflow of options.workflows) {
      if (!validWorkflows.includes(workflow)) {
        throw new Error(i18n.t("errors:invalidWorkflow", { workflow, validWorkflows: validWorkflows.join(", ") }));
      }
    }
  }
  if (options.mcpServices === void 0) {
    options.mcpServices = "all";
    options.mcpServices = MCP_SERVICE_CONFIGS.filter((s) => !s.requiresApiKey).map((s) => s.id);
  }
  if (options.workflows === void 0) {
    options.workflows = "all";
    options.workflows = WORKFLOW_CONFIG_BASE.map((w) => w.id);
  }
}
async function init(options = {}) {
  if (options.skipPrompt) {
    validateSkipPromptOptions(options);
  }
  try {
    if (!options.skipBanner) {
      displayBannerWithInfo();
    }
    if (isTermux()) {
      console.log(ansis.yellow(`
\u2139 ${i18n.t("installation:termuxDetected")}`));
      console.log(ansis.gray(i18n.t("installation:termuxEnvironmentInfo")));
    }
    let configLang = options.configLang;
    if (!configLang && !options.skipPrompt) {
      const LANG_HINT_KEYS = {
        "zh-CN": i18n.t("language:configLangHint.zh-CN"),
        "en": i18n.t("language:configLangHint.en")
      };
      const { lang } = await inquirer.prompt({
        type: "list",
        name: "lang",
        message: i18n.t("language:selectConfigLang"),
        choices: addNumbersToChoices(
          SUPPORTED_LANGS.map((l) => ({
            name: `${LANG_LABELS[l]} - ${LANG_HINT_KEYS[l]}`,
            value: l
          }))
        )
      });
      if (!lang) {
        console.log(ansis.yellow(i18n.t("common:cancelled")));
        process.exit(0);
      }
      configLang = lang;
    } else if (!configLang && options.skipPrompt) {
      configLang = "en";
    }
    const zcfConfig = readZcfConfig();
    const aiOutputLang = options.skipPrompt ? options.aiOutputLang || "en" : await resolveAiOutputLanguage(i18n.language, options.aiOutputLang, zcfConfig);
    const installed = await isClaudeCodeInstalled();
    if (!installed) {
      if (options.skipPrompt) {
        await installClaudeCode();
      } else {
        const { shouldInstall } = await inquirer.prompt({
          type: "confirm",
          name: "shouldInstall",
          message: i18n.t("installation:installPrompt"),
          default: true
        });
        if (shouldInstall === void 0) {
          console.log(ansis.yellow(i18n.t("common:cancelled")));
          process.exit(0);
        }
        if (shouldInstall) {
          await installClaudeCode();
        } else {
          console.log(ansis.yellow(i18n.t("common:skip")));
        }
      }
    } else {
      console.log(ansis.green(`\u2714 ${i18n.t("installation:alreadyInstalled")}`));
      await checkClaudeCodeVersionAndPrompt(options.skipPrompt);
    }
    ensureClaudeDir();
    let action = "new";
    if (existsSync(SETTINGS_FILE) && !options.force) {
      if (options.skipPrompt) {
        action = options.configAction || "backup";
        if (action === "skip") {
          console.log(ansis.yellow(i18n.t("common:skip")));
          return;
        }
      } else {
        const { action: userAction } = await inquirer.prompt({
          type: "list",
          name: "action",
          message: i18n.t("configuration:existingConfig"),
          choices: addNumbersToChoices([
            { name: i18n.t("configuration:backupAndOverwrite"), value: "backup" },
            { name: i18n.t("configuration:updateDocsOnly"), value: "docs-only" },
            { name: i18n.t("configuration:mergeConfig"), value: "merge" },
            { name: i18n.t("common:skip"), value: "skip" }
          ])
        });
        if (!userAction) {
          console.log(ansis.yellow(i18n.t("common:cancelled")));
          process.exit(0);
        }
        action = userAction;
        if (action === "skip") {
          console.log(ansis.yellow(i18n.t("common:skip")));
          return;
        }
      }
    } else if (options.skipPrompt && options.configAction) {
      action = options.configAction;
    }
    let apiConfig = null;
    const isNewInstall = !existsSync(SETTINGS_FILE);
    if (action !== "docs-only" && (isNewInstall || ["backup", "merge", "new"].includes(action))) {
      if (options.skipPrompt) {
        if (options.apiType === "auth_token" && options.apiKey) {
          apiConfig = {
            authType: "auth_token",
            key: options.apiKey,
            url: options.apiUrl || "https://api.anthropic.com"
          };
        } else if (options.apiType === "api_key" && options.apiKey) {
          apiConfig = {
            authType: "api_key",
            key: options.apiKey,
            url: options.apiUrl || "https://api.anthropic.com"
          };
        } else if (options.apiType === "ccr_proxy") {
          const ccrStatus = await isCcrInstalled();
          if (!ccrStatus.hasCorrectPackage) {
            await installCcr();
          } else {
            console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
          }
          const existingCcrConfig = readCcrConfig();
          if (existingCcrConfig) {
            const backupPath = await backupCcrConfig();
            if (backupPath) {
              console.log(ansis.gray(`\u2714 ${i18n.t("ccr:ccrBackupSuccess")}: ${backupPath}`));
            }
          }
          const defaultCcrConfig = createDefaultCcrConfig();
          writeCcrConfig(defaultCcrConfig);
          console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrConfigSuccess")}`));
          await configureCcrProxy(defaultCcrConfig);
          console.log(ansis.green(`\u2714 ${i18n.t("ccr:proxyConfigSuccess")}`));
          try {
            addCompletedOnboarding();
          } catch (error) {
            console.error(ansis.red(i18n.t("errors:failedToSetOnboarding")), error);
          }
          apiConfig = null;
        }
      } else {
        const existingApiConfig = getExistingApiConfig();
        if (existingApiConfig) {
          console.log(`
${ansis.blue(`\u2139 ${i18n.t("api:existingApiConfig")}`)}`);
          console.log(ansis.gray(`  ${i18n.t("api:apiConfigUrl")}: ${existingApiConfig.url || i18n.t("common:notConfigured")}`));
          console.log(
            ansis.gray(
              `  ${i18n.t("api:apiConfigKey")}: ${existingApiConfig.key ? formatApiKeyDisplay(existingApiConfig.key) : i18n.t("common:notConfigured")}`
            )
          );
          console.log(
            ansis.gray(`  ${i18n.t("api:apiConfigAuthType")}: ${existingApiConfig.authType || i18n.t("common:notConfigured")}
`)
          );
          const { action: apiAction } = await inquirer.prompt({
            type: "list",
            name: "action",
            message: i18n.t("api:selectApiAction"),
            choices: addNumbersToChoices([
              { name: i18n.t("api:keepExistingConfig"), value: "keep" },
              { name: i18n.t("api:modifyAllConfig"), value: "modify-all" },
              { name: i18n.t("api:modifyPartialConfig"), value: "modify-partial" },
              { name: i18n.t("api:useCcrProxy"), value: "use-ccr" },
              { name: i18n.t("api:skipApi"), value: "skip" }
            ])
          });
          if (!apiAction) {
            console.log(ansis.yellow(i18n.t("common:cancelled")));
            process.exit(0);
          }
          if (apiAction === "keep" || apiAction === "skip") {
            apiConfig = null;
            if (apiAction === "keep") {
              try {
                addCompletedOnboarding();
              } catch (error) {
                console.error(ansis.red(i18n.t("errors:failedToSetOnboarding")), error);
              }
            }
          } else if (apiAction === "modify-partial") {
            await modifyApiConfigPartially(existingApiConfig);
            apiConfig = null;
          } else if (apiAction === "modify-all") {
            apiConfig = await configureApiCompletely();
          } else if (apiAction === "use-ccr") {
            const ccrStatus = await isCcrInstalled();
            if (!ccrStatus.hasCorrectPackage) {
              await installCcr();
            } else {
              console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
            }
            const ccrConfigured = await setupCcrConfiguration();
            if (ccrConfigured) {
              console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrSetupComplete")}`));
              apiConfig = null;
            }
          }
        } else {
          const { apiChoice } = await inquirer.prompt({
            type: "list",
            name: "apiChoice",
            message: i18n.t("api:configureApi"),
            choices: [
              {
                name: `${i18n.t("api:useAuthToken")} - ${ansis.gray(i18n.t("api:authTokenDesc"))}`,
                value: "auth_token",
                short: i18n.t("api:useAuthToken")
              },
              {
                name: `${i18n.t("api:useApiKey")} - ${ansis.gray(i18n.t("api:apiKeyDesc"))}`,
                value: "api_key",
                short: i18n.t("api:useApiKey")
              },
              {
                name: `${i18n.t("api:useCcrProxy")} - ${ansis.gray(i18n.t("api:ccrProxyDesc"))}`,
                value: "ccr_proxy",
                short: i18n.t("api:useCcrProxy")
              },
              {
                name: i18n.t("api:skipApi"),
                value: "skip"
              }
            ]
          });
          if (!apiChoice) {
            console.log(ansis.yellow(i18n.t("common:cancelled")));
            process.exit(0);
          }
          if (apiChoice === "ccr_proxy") {
            const ccrStatus = await isCcrInstalled();
            if (!ccrStatus.hasCorrectPackage) {
              await installCcr();
            } else {
              console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
            }
            const ccrConfigured = await setupCcrConfiguration();
            if (ccrConfigured) {
              console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrSetupComplete")}`));
              apiConfig = null;
            }
          } else if (apiChoice !== "skip") {
            apiConfig = await configureApiCompletely(apiChoice);
          }
        }
      }
    }
    if (["backup", "docs-only", "merge"].includes(action)) {
      const backupDir = backupExistingConfig();
      if (backupDir) {
        console.log(ansis.gray(`\u2714 ${i18n.t("configuration:backupSuccess")}: ${backupDir}`));
      }
    }
    if (action === "docs-only") {
      copyConfigFiles(true);
      if (options.skipPrompt) {
        if (options.workflows !== false) {
          await selectAndInstallWorkflows(configLang, options.workflows);
        }
      } else {
        await selectAndInstallWorkflows(configLang);
      }
    } else if (["backup", "merge", "new"].includes(action)) {
      copyConfigFiles(false);
      if (options.skipPrompt) {
        if (options.workflows !== false) {
          await selectAndInstallWorkflows(configLang, options.workflows);
        }
      } else {
        await selectAndInstallWorkflows(configLang);
      }
    }
    applyAiLanguageDirective(aiOutputLang);
    if (options.skipPrompt) {
      if (options.outputStyles !== false) {
        await configureOutputStyle(
          options.outputStyles,
          options.defaultOutputStyle
        );
      }
    } else {
      await configureOutputStyle();
    }
    if (apiConfig && action !== "docs-only") {
      const configuredApi = configureApi(apiConfig);
      if (configuredApi) {
        console.log(ansis.green(`\u2714 ${i18n.t("api:apiConfigSuccess")}`));
        console.log(ansis.gray(`  URL: ${configuredApi.url}`));
        console.log(ansis.gray(`  Key: ${formatApiKeyDisplay(configuredApi.key)}`));
      }
    }
    if (action !== "docs-only") {
      let shouldConfigureMcp = false;
      if (options.skipPrompt) {
        shouldConfigureMcp = options.mcpServices !== false;
      } else {
        const { shouldConfigureMcp: userChoice } = await inquirer.prompt({
          type: "confirm",
          name: "shouldConfigureMcp",
          message: i18n.t("mcp:configureMcp"),
          default: true
        });
        if (userChoice === void 0) {
          console.log(ansis.yellow(i18n.t("common:cancelled")));
          process.exit(0);
        }
        shouldConfigureMcp = userChoice;
      }
      if (shouldConfigureMcp) {
        if (isWindows()) {
          console.log(ansis.blue(`\u2139 ${i18n.t("installation:windowsDetected")}`));
        }
        let selectedServices;
        if (options.skipPrompt) {
          selectedServices = options.mcpServices;
        } else {
          selectedServices = await selectMcpServices();
          if (selectedServices === void 0) {
            process.exit(0);
          }
        }
        if (selectedServices.length > 0) {
          const mcpBackupPath = backupMcpConfig();
          if (mcpBackupPath) {
            console.log(ansis.gray(`\u2714 ${i18n.t("mcp:mcpBackupSuccess")}: ${mcpBackupPath}`));
          }
          const newServers = {};
          for (const serviceId of selectedServices) {
            const services = await getMcpServices();
            const service = services.find((s) => s.id === serviceId);
            if (!service)
              continue;
            let config = service.config;
            if (service.requiresApiKey) {
              if (options.skipPrompt) {
                console.log(ansis.yellow(`${i18n.t("common:skip")}: ${service.name} (requires API key)`));
                continue;
              } else {
                const response = await inquirer.prompt({
                  type: "input",
                  name: "apiKey",
                  message: service.apiKeyPrompt,
                  validate: (value) => !!value || i18n.t("api:keyRequired")
                });
                if (!response.apiKey) {
                  console.log(ansis.yellow(`${i18n.t("common:skip")}: ${service.name}`));
                  continue;
                }
                config = buildMcpServerConfig(service.config, response.apiKey, service.apiKeyPlaceholder, service.apiKeyEnvVar);
              }
            }
            newServers[service.id] = config;
          }
          const existingConfig = readMcpConfig();
          let mergedConfig = mergeMcpServers(existingConfig, newServers);
          mergedConfig = fixWindowsMcpConfig(mergedConfig);
          try {
            writeMcpConfig(mergedConfig);
            console.log(ansis.green(`\u2714 ${i18n.t("mcp:mcpConfigSuccess")}`));
          } catch (error) {
            console.error(ansis.red(`${i18n.t("errors:failedToWriteMcpConfig")} ${error}`));
          }
        }
      }
    }
    const cometixInstalled = await isCometixLineInstalled();
    if (!cometixInstalled) {
      let shouldInstallCometix = false;
      if (options.skipPrompt) {
        shouldInstallCometix = options.installCometixLine !== false;
      } else {
        const { shouldInstallCometix: userChoice } = await inquirer.prompt({
          type: "confirm",
          name: "shouldInstallCometix",
          message: i18n.t("cometix:installCometixPrompt"),
          default: true
        });
        if (userChoice === void 0) {
          console.log(ansis.yellow(i18n.t("common:cancelled")));
          process.exit(0);
        }
        shouldInstallCometix = userChoice;
      }
      if (shouldInstallCometix) {
        await installCometixLine();
      } else {
        console.log(ansis.yellow(i18n.t("cometix:cometixSkipped")));
      }
    } else {
      console.log(ansis.green(`\u2714 ${i18n.t("cometix:cometixAlreadyInstalled")}`));
    }
    updateZcfConfig({
      version,
      preferredLang: i18n.language,
      aiOutputLang
    });
    console.log(ansis.green(`\u2714 ${i18n.t("configuration:configSuccess")} ${CLAUDE_DIR}`));
    console.log(`
${ansis.cyan(i18n.t("common:complete"))}`);
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
  }
}

const __dirname = dirname(fileURLToPath(import.meta.url));
function getTemplateSettings() {
  const templatePath = join(__dirname, "../../templates/common/settings.json");
  const content = readFileSync(templatePath, "utf-8");
  return JSON.parse(content);
}
function loadCurrentSettings() {
  if (!existsSync(SETTINGS_FILE)) {
    return {};
  }
  try {
    const content = readFileSync(SETTINGS_FILE, "utf-8");
    return JSON.parse(content);
  } catch {
    return {};
  }
}
function saveSettings(settings) {
  ensureDir(CLAUDE_DIR);
  writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
}
async function importRecommendedEnv() {
  const templateSettings = getTemplateSettings();
  const currentSettings = loadCurrentSettings();
  currentSettings.env = {
    ...currentSettings.env,
    ...templateSettings.env
  };
  saveSettings(currentSettings);
}
async function importRecommendedPermissions() {
  const templateSettings = getTemplateSettings();
  const currentSettings = loadCurrentSettings();
  if (templateSettings.permissions && templateSettings.permissions.allow) {
    currentSettings.permissions = {
      ...templateSettings.permissions,
      allow: mergeAndCleanPermissions(
        templateSettings.permissions.allow,
        currentSettings.permissions?.allow
      )
    };
  } else {
    currentSettings.permissions = templateSettings.permissions;
  }
  saveSettings(currentSettings);
}
async function openSettingsJson() {
  ensureDir(CLAUDE_DIR);
  if (!existsSync(SETTINGS_FILE)) {
    saveSettings({});
  }
  const platform = getPlatform();
  let command;
  switch (platform) {
    case "macos":
      command = "open";
      break;
    case "windows":
      command = "start";
      break;
    default:
      command = "xdg-open";
  }
  try {
    await exec(command, [SETTINGS_FILE]);
  } catch {
    try {
      await exec("code", [SETTINGS_FILE]);
    } catch {
      try {
        await exec("vim", [SETTINGS_FILE]);
      } catch {
        await exec("nano", [SETTINGS_FILE]);
      }
    }
  }
}

export { getMcpServices as $, AI_OUTPUT_LANGUAGES as A, readMcpConfig as B, CLAUDE_DIR as C, writeMcpConfig as D, backupMcpConfig as E, mergeMcpServers as F, buildMcpServerConfig as G, fixWindowsMcpConfig as H, addCompletedOnboarding as I, ensureI18nInitialized as J, i18n as K, LEGACY_ZCF_CONFIG_FILE as L, readCcrConfig as M, isCcrInstalled as N, installCcr as O, configureCcrFeature as P, handleExitPromptError as Q, handleGeneralError as R, SETTINGS_FILE as S, addNumbersToChoices as T, updateZcfConfig as U, changeLanguage as V, readZcfConfig as W, configureOutputStyle as X, isWindows as Y, ZCF_CONFIG_FILE as Z, selectMcpServices as _, commandExists as a, formatApiKeyDisplay as a0, modifyApiConfigPartially as a1, setupCcrConfiguration as a2, validateApiKey as a3, COMETIX_COMMAND_NAME as a4, COMETIX_COMMANDS as a5, installCometixLine as a6, checkAndUpdateTools as a7, displayBanner as a8, resolveAiOutputLanguage as a9, updatePromptOnly as aa, selectAndInstallWorkflows as ab, checkClaudeCodeVersionAndPrompt as ac, version as ad, displayBannerWithInfo as ae, readZcfConfigAsync as af, initI18n as ag, selectScriptLanguage as ah, prompts as ai, importRecommendedEnv as b, cleanupPermissions as c, importRecommendedPermissions as d, CLAUDE_MD_FILE as e, ClAUDE_CONFIG_FILE as f, getPlatform as g, SUPPORTED_LANGS as h, init as i, LANG_LABELS as j, getAiOutputLanguageLabel as k, ensureClaudeDir as l, mergeAndCleanPermissions as m, backupExistingConfig as n, openSettingsJson as o, copyConfigFiles as p, configureApi as q, mergeConfigs as r, mergeSettingsFile as s, getExistingModelConfig as t, updateDefaultModel as u, getExistingApiConfig as v, applyAiLanguageDirective as w, isClaudeCodeInstalled as x, installClaudeCode as y, getMcpConfigPath as z };
