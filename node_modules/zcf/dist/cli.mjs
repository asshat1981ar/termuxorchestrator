#!/usr/bin/env node
import cac from 'cac';
import ansis from 'ansis';
import { J as ensureI18nInitialized, K as i18n, M as readCcrConfig, N as isCcrInstalled, O as installCcr, P as configureCcrFeature, Q as handleExitPromptError, R as handleGeneralError, Z as ZCF_CONFIG_FILE, h as SUPPORTED_LANGS, T as addNumbersToChoices, j as LANG_LABELS, U as updateZcfConfig, V as changeLanguage, o as openSettingsJson, d as importRecommendedPermissions, b as importRecommendedEnv, W as readZcfConfig, w as applyAiLanguageDirective, X as configureOutputStyle, t as getExistingModelConfig, u as updateDefaultModel, Y as isWindows, B as readMcpConfig, H as fixWindowsMcpConfig, D as writeMcpConfig, _ as selectMcpServices, E as backupMcpConfig, $ as getMcpServices, G as buildMcpServerConfig, F as mergeMcpServers, v as getExistingApiConfig, a0 as formatApiKeyDisplay, I as addCompletedOnboarding, a1 as modifyApiConfigPartially, a2 as setupCcrConfiguration, a3 as validateApiKey, q as configureApi, a4 as COMETIX_COMMAND_NAME, a5 as COMETIX_COMMANDS, a6 as installCometixLine, a7 as checkAndUpdateTools, a8 as displayBanner, a9 as resolveAiOutputLanguage, aa as updatePromptOnly, ab as selectAndInstallWorkflows, ac as checkClaudeCodeVersionAndPrompt, ad as version, ae as displayBannerWithInfo, i as init, af as readZcfConfigAsync, ag as initI18n, ah as selectScriptLanguage } from './chunks/simple-config.mjs';
import { existsSync, unlinkSync } from 'node:fs';
import { homedir } from 'node:os';
import inquirer from 'inquirer';
import { join } from 'pathe';
import { exec, spawn } from 'node:child_process';
import { promisify } from 'node:util';
import process from 'node:process';
import { x } from 'tinyexec';
import 'node:url';
import 'i18next';
import 'i18next-fs-backend';
import 'dayjs';
import 'ora';
import 'semver';
import 'node:fs/promises';

const execAsync$1 = promisify(exec);
async function runCcrUi(apiKey) {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u{1F5A5}\uFE0F  ${i18n.t("ccr:startingCcrUi")}`));
  if (apiKey) {
    console.log(ansis.bold.green(`
\u{1F511} ${i18n.t("ccr:ccrUiApiKey") || "CCR UI API Key"}: ${apiKey}`));
    console.log(ansis.gray(`   ${i18n.t("ccr:ccrUiApiKeyHint") || "Use this API key to login to CCR UI"}
`));
  }
  try {
    const { stdout, stderr } = await execAsync$1("ccr ui");
    if (stdout)
      console.log(stdout);
    if (stderr)
      console.error(ansis.yellow(stderr));
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrUiStarted")}`));
  } catch (error) {
    console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrCommandFailed")}: ${error instanceof Error ? error.message : String(error)}`));
    throw error;
  }
}
async function runCcrStatus() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u{1F4CA} ${i18n.t("ccr:checkingCcrStatus")}`));
  try {
    const { stdout, stderr } = await execAsync$1("ccr status");
    if (stdout) {
      console.log(`
${ansis.bold(i18n.t("ccr:ccrStatusTitle"))}`);
      console.log(stdout);
    }
    if (stderr)
      console.error(ansis.yellow(stderr));
  } catch (error) {
    console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrCommandFailed")}: ${error instanceof Error ? error.message : String(error)}`));
    throw error;
  }
}
async function runCcrRestart() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u{1F504} ${i18n.t("ccr:restartingCcr")}`));
  try {
    const { stdout, stderr } = await execAsync$1("ccr restart");
    if (stdout)
      console.log(stdout);
    if (stderr)
      console.error(ansis.yellow(stderr));
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrRestarted")}`));
  } catch (error) {
    console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrCommandFailed")}: ${error instanceof Error ? error.message : String(error)}`));
    throw error;
  }
}
async function runCcrStart() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u25B6\uFE0F  ${i18n.t("ccr:startingCcr")}`));
  try {
    const { stdout, stderr } = await execAsync$1("ccr start");
    if (stdout)
      console.log(stdout);
    if (stderr)
      console.error(ansis.yellow(stderr));
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrStarted")}`));
  } catch (error) {
    if (error.stdout && error.stdout.includes("Loaded JSON config from:")) {
      console.log(error.stdout);
      if (error.stderr)
        console.error(ansis.yellow(error.stderr));
      console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrStarted")}`));
    } else {
      console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrCommandFailed")}: ${error instanceof Error ? error.message : String(error)}`));
      throw error;
    }
  }
}
async function runCcrStop() {
  ensureI18nInitialized();
  console.log(ansis.cyan(`
\u23F9\uFE0F  ${i18n.t("ccr:stoppingCcr")}`));
  try {
    const { stdout, stderr } = await execAsync$1("ccr stop");
    if (stdout)
      console.log(stdout);
    if (stderr)
      console.error(ansis.yellow(stderr));
    console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrStopped")}`));
  } catch (error) {
    console.error(ansis.red(`\u2716 ${i18n.t("ccr:ccrCommandFailed")}: ${error instanceof Error ? error.message : String(error)}`));
    throw error;
  }
}

function isCcrConfigured() {
  const CCR_CONFIG_FILE = join(homedir(), ".claude-code-router", "config.json");
  if (!existsSync(CCR_CONFIG_FILE)) {
    return false;
  }
  const config = readCcrConfig();
  return config !== null;
}
async function showCcrMenu() {
  try {
    ensureI18nInitialized();
    console.log(`
${ansis.cyan("\u2550".repeat(50))}`);
    console.log(ansis.bold.cyan(`  ${i18n.t("ccr:ccrMenuTitle")}`));
    console.log(`${ansis.cyan("\u2550".repeat(50))}
`);
    console.log(`  ${ansis.cyan("1.")} ${i18n.t("ccr:ccrMenuOptions.initCcr")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.initCcr")}`)}`);
    console.log(`  ${ansis.cyan("2.")} ${i18n.t("ccr:ccrMenuOptions.startUi")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.startUi")}`)}`);
    console.log(`  ${ansis.cyan("3.")} ${i18n.t("ccr:ccrMenuOptions.checkStatus")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.checkStatus")}`)}`);
    console.log(`  ${ansis.cyan("4.")} ${i18n.t("ccr:ccrMenuOptions.restart")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.restart")}`)}`);
    console.log(`  ${ansis.cyan("5.")} ${i18n.t("ccr:ccrMenuOptions.start")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.start")}`)}`);
    console.log(`  ${ansis.cyan("6.")} ${i18n.t("ccr:ccrMenuOptions.stop")} ${ansis.gray(`- ${i18n.t("ccr:ccrMenuDescriptions.stop")}`)}`);
    console.log(`  ${ansis.yellow("0.")} ${i18n.t("ccr:ccrMenuOptions.back")}`);
    console.log("");
    const { choice } = await inquirer.prompt({
      type: "input",
      name: "choice",
      message: i18n.t("common:enterChoice"),
      validate: (value) => {
        const valid = ["1", "2", "3", "4", "5", "6", "0"];
        return valid.includes(value) || i18n.t("common:invalidChoice");
      }
    });
    switch (choice) {
      case "1": {
        const ccrStatus = await isCcrInstalled();
        if (!ccrStatus.hasCorrectPackage) {
          await installCcr();
        } else {
          console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
        }
        await configureCcrFeature();
        console.log(ansis.green(`
\u2714 ${i18n.t("ccr:ccrSetupComplete")}`));
        break;
      }
      case "2":
        if (!isCcrConfigured()) {
          console.log(ansis.yellow(`
\u26A0\uFE0F  ${i18n.t("ccr:ccrNotConfigured")}`));
          console.log(ansis.cyan(`   ${i18n.t("ccr:pleaseInitFirst")}
`));
        } else {
          const config = readCcrConfig();
          await runCcrUi(config?.APIKEY);
        }
        break;
      case "3":
        if (!isCcrConfigured()) {
          console.log(ansis.yellow(`
\u26A0\uFE0F  ${i18n.t("ccr:ccrNotConfigured")}`));
          console.log(ansis.cyan(`   ${i18n.t("ccr:pleaseInitFirst")}
`));
        } else {
          await runCcrStatus();
        }
        break;
      case "4":
        if (!isCcrConfigured()) {
          console.log(ansis.yellow(`
\u26A0\uFE0F  ${i18n.t("ccr:ccrNotConfigured")}`));
          console.log(ansis.cyan(`   ${i18n.t("ccr:pleaseInitFirst")}
`));
        } else {
          await runCcrRestart();
        }
        break;
      case "5":
        if (!isCcrConfigured()) {
          console.log(ansis.yellow(`
\u26A0\uFE0F  ${i18n.t("ccr:ccrNotConfigured")}`));
          console.log(ansis.cyan(`   ${i18n.t("ccr:pleaseInitFirst")}
`));
        } else {
          await runCcrStart();
        }
        break;
      case "6":
        if (!isCcrConfigured()) {
          console.log(ansis.yellow(`
\u26A0\uFE0F  ${i18n.t("ccr:ccrNotConfigured")}`));
          console.log(ansis.cyan(`   ${i18n.t("ccr:pleaseInitFirst")}
`));
        } else {
          await runCcrStop();
        }
        break;
      case "0":
        return false;
    }
    if (choice !== "0") {
      console.log(`
${ansis.dim("\u2500".repeat(50))}
`);
      const { continueInCcr } = await inquirer.prompt({
        type: "confirm",
        name: "continueInCcr",
        message: i18n.t("common:returnToMenu"),
        default: true
      });
      if (continueInCcr) {
        return await showCcrMenu();
      }
    }
    return false;
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
    return false;
  }
}

async function handleCancellation() {
  ensureI18nInitialized();
  console.log(ansis.yellow(i18n.t("common:cancelled")));
}
async function configureApiFeature() {
  ensureI18nInitialized();
  const existingApiConfig = getExistingApiConfig();
  if (existingApiConfig) {
    console.log(`
${ansis.blue(`\u2139 ${i18n.t("api:existingApiConfig")}`)}`);
    console.log(ansis.gray(`  ${i18n.t("api:apiConfigUrl")}: ${existingApiConfig.url || i18n.t("common:notConfigured")}`));
    console.log(
      ansis.gray(
        `  ${i18n.t("api:apiConfigKey")}: ${existingApiConfig.key ? formatApiKeyDisplay(existingApiConfig.key) : i18n.t("common:notConfigured")}`
      )
    );
    console.log(
      ansis.gray(`  ${i18n.t("api:apiConfigAuthType")}: ${existingApiConfig.authType || i18n.t("common:notConfigured")}
`)
    );
    const { action } = await inquirer.prompt({
      type: "list",
      name: "action",
      message: i18n.t("api:selectApiAction"),
      choices: addNumbersToChoices([
        { name: i18n.t("api:keepExistingConfig"), value: "keep" },
        { name: i18n.t("api:modifyAllConfig"), value: "modify-all" },
        { name: i18n.t("api:modifyPartialConfig"), value: "modify-partial" },
        { name: i18n.t("api:useCcrProxy"), value: "use-ccr" }
      ])
    });
    if (!action) {
      await handleCancellation();
      return;
    }
    if (action === "keep") {
      console.log(ansis.green(`\u2714 ${i18n.t("api:keepExistingConfig")}`));
      try {
        addCompletedOnboarding();
      } catch (error) {
        console.error(ansis.red(i18n.t("errors:failedToSetOnboarding")), error);
      }
      return;
    } else if (action === "modify-partial") {
      await modifyApiConfigPartially(existingApiConfig);
      return;
    } else if (action === "use-ccr") {
      const ccrStatus = await isCcrInstalled();
      if (!ccrStatus.hasCorrectPackage) {
        await installCcr();
      } else {
        console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
      }
      const ccrConfigured = await setupCcrConfiguration();
      if (ccrConfigured) {
        console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrSetupComplete")}`));
      }
      return;
    }
  }
  const { apiChoice } = await inquirer.prompt({
    type: "list",
    name: "apiChoice",
    message: i18n.t("api:configureApi"),
    choices: addNumbersToChoices([
      {
        name: `${i18n.t("api:useAuthToken")} - ${ansis.gray(i18n.t("api:authTokenDesc"))}`,
        value: "auth_token",
        short: i18n.t("api:useAuthToken")
      },
      {
        name: `${i18n.t("api:useApiKey")} - ${ansis.gray(i18n.t("api:apiKeyDesc"))}`,
        value: "api_key",
        short: i18n.t("api:useApiKey")
      },
      {
        name: `${i18n.t("api:useCcrProxy")} - ${ansis.gray(i18n.t("api:ccrProxyDesc"))}`,
        value: "ccr_proxy",
        short: i18n.t("api:useCcrProxy")
      },
      { name: i18n.t("api:skipApi"), value: "skip" }
    ])
  });
  if (!apiChoice || apiChoice === "skip") {
    return;
  }
  if (apiChoice === "ccr_proxy") {
    const ccrStatus = await isCcrInstalled();
    if (!ccrStatus.hasCorrectPackage) {
      await installCcr();
    } else {
      console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrAlreadyInstalled")}`));
    }
    const ccrConfigured = await setupCcrConfiguration();
    if (ccrConfigured) {
      console.log(ansis.green(`\u2714 ${i18n.t("ccr:ccrSetupComplete")}`));
    }
    return;
  }
  const { url } = await inquirer.prompt({
    type: "input",
    name: "url",
    message: i18n.t("api:enterApiUrl"),
    validate: async (value) => {
      if (!value)
        return i18n.t("api:urlRequired");
      try {
        void new URL(value);
        return true;
      } catch {
        return i18n.t("api:invalidUrl");
      }
    }
  });
  if (!url) {
    await handleCancellation();
    return;
  }
  const keyMessage = apiChoice === "auth_token" ? i18n.t("api:enterAuthToken") : i18n.t("api:enterApiKey");
  const { key } = await inquirer.prompt({
    type: "input",
    name: "key",
    message: keyMessage,
    validate: async (value) => {
      if (!value) {
        return i18n.t("api:keyRequired");
      }
      const validation = await validateApiKey(value);
      if (!validation.isValid) {
        return validation.error || i18n.t("api:invalidKeyFormat");
      }
      return true;
    }
  });
  if (!key) {
    await handleCancellation();
    return;
  }
  const apiConfig = { url, key, authType: apiChoice };
  const configuredApi = configureApi(apiConfig);
  if (configuredApi) {
    console.log(ansis.green(`\u2714 ${i18n.t("api:apiConfigSuccess")}`));
    console.log(ansis.gray(`  URL: ${configuredApi.url}`));
    console.log(ansis.gray(`  Key: ${formatApiKeyDisplay(configuredApi.key)}`));
  }
}
async function configureMcpFeature() {
  ensureI18nInitialized();
  if (isWindows()) {
    const { fixWindows } = await inquirer.prompt({
      type: "confirm",
      name: "fixWindows",
      message: i18n.t("configuration:fixWindowsMcp") || "Fix Windows MCP configuration?",
      default: true
    });
    if (fixWindows) {
      const existingConfig = readMcpConfig() || { mcpServers: {} };
      const fixedConfig = fixWindowsMcpConfig(existingConfig);
      writeMcpConfig(fixedConfig);
      console.log(ansis.green(`\u2714 Windows MCP configuration fixed`));
    }
  }
  const selectedServices = await selectMcpServices();
  if (!selectedServices) {
    return;
  }
  if (selectedServices.length > 0) {
    const mcpBackupPath = backupMcpConfig();
    if (mcpBackupPath) {
      console.log(ansis.gray(`\u2714 ${i18n.t("mcp:mcpBackupSuccess")}: ${mcpBackupPath}`));
    }
    const newServers = {};
    for (const serviceId of selectedServices) {
      const service = (await getMcpServices()).find((s) => s.id === serviceId);
      if (!service)
        continue;
      let config = service.config;
      if (service.requiresApiKey) {
        const { apiKey } = await inquirer.prompt({
          type: "input",
          name: "apiKey",
          message: service.apiKeyPrompt,
          validate: async (value) => !!value || i18n.t("api:keyRequired")
        });
        if (apiKey) {
          config = buildMcpServerConfig(service.config, apiKey, service.apiKeyPlaceholder, service.apiKeyEnvVar);
        } else {
          continue;
        }
      }
      newServers[service.id] = config;
    }
    const existingConfig = readMcpConfig();
    let mergedConfig = mergeMcpServers(existingConfig, newServers);
    mergedConfig = fixWindowsMcpConfig(mergedConfig);
    writeMcpConfig(mergedConfig);
    console.log(ansis.green(`\u2714 ${i18n.t("mcp:mcpConfigSuccess")}`));
  }
}
async function configureDefaultModelFeature() {
  ensureI18nInitialized();
  const existingModel = getExistingModelConfig();
  if (existingModel) {
    console.log(`
${ansis.blue(`\u2139 ${i18n.t("configuration:existingModelConfig") || "Existing model configuration"}`)}`);
    const modelDisplay = existingModel === "default" ? i18n.t("configuration:defaultModelOption") || "Default (Let Claude Code choose)" : existingModel.charAt(0).toUpperCase() + existingModel.slice(1);
    console.log(ansis.gray(`  ${i18n.t("configuration:currentModel") || "Current model"}: ${modelDisplay}
`));
    const { modify } = await inquirer.prompt({
      type: "confirm",
      name: "modify",
      message: i18n.t("configuration:modifyModel") || "Modify model configuration?",
      default: false
    });
    if (!modify) {
      console.log(ansis.green(`\u2714 ${i18n.t("configuration:keepModel") || "Keeping existing model configuration"}`));
      return;
    }
  }
  const { model } = await inquirer.prompt({
    type: "list",
    name: "model",
    message: i18n.t("configuration:selectDefaultModel") || "Select default model",
    choices: addNumbersToChoices([
      {
        name: i18n.t("configuration:defaultModelOption") || "Default - Let Claude Code choose",
        value: "default"
      },
      {
        name: i18n.t("configuration:opusModelOption") || "Opus - Only use opus, high token consumption, use with caution",
        value: "opus"
      },
      {
        name: i18n.t("configuration:opusPlanModelOption") || "OpusPlan - Use Opus for planning, write code with sonnet, recommended",
        value: "opusplan"
      }
    ]),
    default: existingModel ? ["default", "opus", "opusplan"].indexOf(existingModel) : 0
  });
  if (!model) {
    await handleCancellation();
    return;
  }
  updateDefaultModel(model);
  console.log(ansis.green(`\u2714 ${i18n.t("configuration:modelConfigured") || "Default model configured"}`));
}
async function configureAiMemoryFeature() {
  ensureI18nInitialized();
  const { option } = await inquirer.prompt({
    type: "list",
    name: "option",
    message: i18n.t("configuration:selectMemoryOption") || "Select configuration option",
    choices: addNumbersToChoices([
      {
        name: i18n.t("configuration:configureAiLanguage") || "Configure AI output language",
        value: "language"
      },
      {
        name: i18n.t("configuration:configureOutputStyle") || "Configure global AI output style",
        value: "outputStyle"
      }
    ])
  });
  if (!option) {
    return;
  }
  if (option === "language") {
    const zcfConfig = readZcfConfig();
    const existingLang = zcfConfig?.aiOutputLang;
    if (existingLang) {
      console.log(
        `
${ansis.blue(`\u2139 ${i18n.t("configuration:existingLanguageConfig") || "Existing AI output language configuration"}`)}`
      );
      console.log(ansis.gray(`  ${i18n.t("configuration:currentLanguage") || "Current language"}: ${existingLang}
`));
      const { modify } = await inquirer.prompt({
        type: "confirm",
        name: "modify",
        message: i18n.t("configuration:modifyLanguage") || "Modify AI output language?",
        default: false
      });
      if (!modify) {
        console.log(ansis.green(`\u2714 ${i18n.t("configuration:keepLanguage") || "Keeping existing language configuration"}`));
        return;
      }
    }
    const { selectAiOutputLanguage } = await import('./chunks/simple-config.mjs').then(function (n) { return n.ai; });
    const aiOutputLang = await selectAiOutputLanguage();
    applyAiLanguageDirective(aiOutputLang);
    updateZcfConfig({ aiOutputLang });
    console.log(ansis.green(`\u2714 ${i18n.t("configuration:aiLanguageConfigured") || "AI output language configured"}`));
  } else if (option === "outputStyle") {
    await configureOutputStyle();
  }
}
async function clearZcfCacheFeature() {
  ensureI18nInitialized();
  const { confirm } = await inquirer.prompt({
    type: "confirm",
    name: "confirm",
    message: i18n.t("configuration:confirmClearCache") || "Clear all ZCF preferences cache?",
    default: false
  });
  if (!confirm) {
    await handleCancellation();
    return;
  }
  if (existsSync(ZCF_CONFIG_FILE)) {
    unlinkSync(ZCF_CONFIG_FILE);
    console.log(ansis.green(`\u2714 ${i18n.t("configuration:cacheCleared") || "ZCF cache cleared"}`));
  } else {
    console.log(ansis.yellow("No cache found"));
  }
}
async function changeScriptLanguageFeature(currentLang) {
  ensureI18nInitialized();
  const { lang } = await inquirer.prompt({
    type: "list",
    name: "lang",
    message: i18n.t("language:selectScriptLang"),
    choices: addNumbersToChoices(
      SUPPORTED_LANGS.map((l) => ({
        name: LANG_LABELS[l],
        value: l
      }))
    ),
    default: SUPPORTED_LANGS.indexOf(currentLang)
  });
  if (!lang) {
    return currentLang;
  }
  updateZcfConfig({ preferredLang: lang });
  await changeLanguage(lang);
  console.log(ansis.green(`\u2714 ${i18n.t("language:languageChanged") || "Language changed"}`));
  return lang;
}
async function configureEnvPermissionFeature() {
  ensureI18nInitialized();
  const { choice } = await inquirer.prompt({
    type: "list",
    name: "choice",
    message: i18n.t("configuration:selectEnvPermissionOption") || "Select option",
    choices: addNumbersToChoices([
      {
        name: `${i18n.t("configuration:importRecommendedEnv") || "Import environment"} ${ansis.gray(
          `- ${i18n.t("configuration:importRecommendedEnvDesc") || "Import env settings"}`
        )}`,
        value: "env"
      },
      {
        name: `${i18n.t("configuration:importRecommendedPermissions") || "Import permissions"} ${ansis.gray(
          `- ${i18n.t("configuration:importRecommendedPermissionsDesc") || "Import permission settings"}`
        )}`,
        value: "permissions"
      },
      {
        name: `${i18n.t("configuration:openSettingsJson") || "Open settings"} ${ansis.gray(
          `- ${i18n.t("configuration:openSettingsJsonDesc") || "View settings file"}`
        )}`,
        value: "open"
      }
    ])
  });
  if (!choice) {
    await handleCancellation();
    return;
  }
  try {
    switch (choice) {
      case "env":
        await importRecommendedEnv();
        console.log(ansis.green(`\u2705 ${i18n.t("configuration:envImportSuccess")}`));
        break;
      case "permissions":
        await importRecommendedPermissions();
        console.log(ansis.green(`\u2705 ${i18n.t("configuration:permissionsImportSuccess") || "Permissions imported"}`));
        break;
      case "open":
        console.log(ansis.cyan(i18n.t("configuration:openingSettingsJson") || "Opening settings.json..."));
        await openSettingsJson();
        break;
    }
  } catch (error) {
    console.error(ansis.red(`${i18n.t("common:error")}: ${error.message}`));
  }
}

async function executeCcusage(args = []) {
  try {
    const command = "npx";
    const commandArgs = ["ccusage@latest", ...args || []];
    console.log(ansis.cyan(i18n.t("tools:runningCcusage")));
    console.log(ansis.gray(`$ npx ccusage@latest ${(args || []).join(" ")}`));
    console.log("");
    await x(command, commandArgs, {
      nodeOptions: {
        stdio: "inherit"
      }
    });
  } catch (error) {
    console.error(ansis.red(i18n.t("tools:ccusageFailed")));
    console.error(ansis.yellow(i18n.t("tools:checkNetworkConnection")));
    if (process.env.DEBUG) {
      console.error(ansis.gray(i18n.t("tools:errorDetails")), error);
    }
    if (process.env.NODE_ENV !== "test") {
      process.exit(1);
    }
    throw error;
  }
}

const execAsync = promisify(exec);
async function runCometixPrintConfig() {
  ensureI18nInitialized();
  try {
    console.log(ansis.blue(`${i18n.t("cometix:printingConfig")}`));
    const { stdout } = await execAsync(COMETIX_COMMANDS.PRINT_CONFIG);
    console.log(stdout);
  } catch (error) {
    if (error.message.includes(`command not found: ${COMETIX_COMMAND_NAME}`)) {
      console.error(ansis.red(`\u2717 ${i18n.t("cometix:commandNotFound")}`));
    } else {
      console.error(ansis.red(`\u2717 ${i18n.t("cometix:printConfigFailed")}: ${error}`));
    }
    throw error;
  }
}
async function runCometixTuiConfig() {
  ensureI18nInitialized();
  return new Promise((resolve, reject) => {
    console.log(ansis.blue(`${i18n.t("cometix:enteringTuiConfig")}`));
    const child = spawn(COMETIX_COMMAND_NAME, ["-c"], {
      stdio: "inherit",
      // This allows the TUI to interact directly with the terminal
      shell: true
    });
    child.on("close", (code) => {
      if (code === 0) {
        console.log(ansis.green(`\u2713 ${i18n.t("cometix:tuiConfigSuccess")}`));
        resolve();
      } else {
        const error = new Error(`${COMETIX_COMMAND_NAME} -c exited with code ${code}`);
        console.error(ansis.red(`\u2717 ${i18n.t("cometix:tuiConfigFailed")}: ${error.message}`));
        reject(error);
      }
    });
    child.on("error", (error) => {
      if (error.message.includes(`command not found`) || error.message.includes("ENOENT")) {
        console.error(ansis.red(`\u2717 ${i18n.t("cometix:commandNotFound")}`));
      } else {
        console.error(ansis.red(`\u2717 ${i18n.t("cometix:tuiConfigFailed")}: ${error.message}`));
      }
      reject(error);
    });
  });
}

async function showCometixMenu() {
  try {
    ensureI18nInitialized();
    console.log(`
${ansis.cyan("\u2550".repeat(50))}`);
    console.log(ansis.bold.cyan(`  ${i18n.t("cometix:cometixMenuTitle")}`));
    console.log(`${ansis.cyan("\u2550".repeat(50))}
`);
    console.log(`  ${ansis.cyan("1.")} ${i18n.t("cometix:cometixMenuOptions.installOrUpdate")} ${ansis.gray(`- ${i18n.t("cometix:cometixMenuDescriptions.installOrUpdate")}`)}`);
    console.log(`  ${ansis.cyan("2.")} ${i18n.t("cometix:cometixMenuOptions.printConfig")} ${ansis.gray(`- ${i18n.t("cometix:cometixMenuDescriptions.printConfig")}`)}`);
    console.log(`  ${ansis.cyan("3.")} ${i18n.t("cometix:cometixMenuOptions.customConfig")} ${ansis.gray(`- ${i18n.t("cometix:cometixMenuDescriptions.customConfig")}`)}`);
    console.log(`  ${ansis.yellow("0.")} ${i18n.t("cometix:cometixMenuOptions.back")}`);
    console.log("");
    const { choice } = await inquirer.prompt({
      type: "input",
      name: "choice",
      message: i18n.t("common:enterChoice"),
      validate: async (value) => {
        const valid = ["1", "2", "3", "0"];
        return valid.includes(value) || i18n.t("common:invalidChoice");
      }
    });
    switch (choice) {
      case "1":
        await installCometixLine();
        break;
      case "2":
        await runCometixPrintConfig();
        break;
      case "3":
        await runCometixTuiConfig();
        break;
      case "0":
        return false;
    }
    if (choice !== "0") {
      console.log(`
${ansis.dim("\u2500".repeat(50))}
`);
      const { continueInCometix } = await inquirer.prompt({
        type: "confirm",
        name: "continueInCometix",
        message: i18n.t("common:returnToMenu"),
        default: true
      });
      if (continueInCometix) {
        return await showCometixMenu();
      }
    }
    return false;
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
    return false;
  }
}

async function runCcusageFeature() {
  ensureI18nInitialized();
  console.log("");
  console.log(ansis.cyan(i18n.t("menu:menuOptions.ccusage")));
  console.log(ansis.gray(`${i18n.t("tools:ccusageDescription")}`));
  console.log("");
  const choices = [
    { name: i18n.t("tools:ccusageModes.daily"), value: "daily" },
    { name: i18n.t("tools:ccusageModes.monthly"), value: "monthly" },
    { name: i18n.t("tools:ccusageModes.session"), value: "session" },
    { name: i18n.t("tools:ccusageModes.blocks"), value: "blocks" },
    { name: i18n.t("tools:ccusageModes.custom"), value: "custom" },
    { name: i18n.t("common:back"), value: "back" }
  ];
  const { mode } = await inquirer.prompt({
    type: "list",
    name: "mode",
    message: i18n.t("tools:selectAnalysisMode"),
    choices: addNumbersToChoices(choices)
  });
  if (mode === "back") {
    return;
  }
  let args = [];
  if (mode === "custom") {
    const { customArgs } = await inquirer.prompt({
      type: "input",
      name: "customArgs",
      message: i18n.t("tools:enterCustomArgs"),
      default: ""
    });
    if (customArgs === null || customArgs === void 0 || customArgs === "") {
      args = [];
    } else {
      const argsString = String(customArgs).trim();
      if (!argsString) {
        args = [];
      } else {
        const argPattern = /"([^"]*)"|'([^']*)'|(\S+)/g;
        const matches = [];
        let match = argPattern.exec(argsString);
        while (match !== null) {
          const value = match[1] || match[2] || match[3];
          if (value) {
            matches.push(value);
          }
          match = argPattern.exec(argsString);
        }
        args = matches;
      }
    }
  } else {
    args = [mode];
  }
  console.log("");
  await executeCcusage(args);
  console.log("");
  await inquirer.prompt({
    type: "input",
    name: "continue",
    message: ansis.gray(i18n.t("tools:pressEnterToContinue"))
  });
}
async function runCcrMenuFeature() {
  await showCcrMenu();
}
async function runCometixMenuFeature() {
  await showCometixMenu();
}

async function checkUpdates() {
  try {
    await checkAndUpdateTools();
  } catch (error) {
    console.error(ansis.red(i18n.t("updater:errorCheckingUpdates")), error);
    process.exit(1);
  }
}

async function update(options = {}) {
  try {
    if (!options.skipBanner) {
      displayBanner(i18n.t("cli:banner.updateSubtitle"));
    }
    const zcfConfig = readZcfConfig();
    let configLang = options.configLang;
    if (!configLang) {
      const LANG_HINT_KEYS = {
        "zh-CN": i18n.t("language:configLangHint.zh-CN"),
        "en": i18n.t("language:configLangHint.en")
      };
      const { lang } = await inquirer.prompt({
        type: "list",
        name: "lang",
        message: i18n.t("language:updateConfigLangPrompt"),
        choices: addNumbersToChoices(SUPPORTED_LANGS.map((l) => ({
          name: `${LANG_LABELS[l]} - ${LANG_HINT_KEYS[l]}`,
          value: l
        })))
      });
      if (!lang) {
        console.log(ansis.yellow(i18n.t("common:cancelled")));
        process.exit(0);
      }
      configLang = lang;
    }
    const aiOutputLang = await resolveAiOutputLanguage(i18n.language, options.aiOutputLang, zcfConfig);
    console.log(ansis.cyan(`
${i18n.t("configuration:updatingPrompts")}
`));
    await updatePromptOnly(aiOutputLang);
    await selectAndInstallWorkflows(configLang);
    await checkClaudeCodeVersionAndPrompt(false);
    updateZcfConfig({
      version,
      aiOutputLang
    });
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
  }
}

async function showMainMenu() {
  try {
    displayBannerWithInfo();
    let exitMenu = false;
    while (!exitMenu) {
      console.log(ansis.cyan(i18n.t("menu:selectFunction")));
      console.log("  -------- Claude Code --------");
      console.log(
        `  ${ansis.cyan("1.")} ${i18n.t("menu:menuOptions.fullInit")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.fullInit")}`)}`
      );
      console.log(
        `  ${ansis.cyan("2.")} ${i18n.t("menu:menuOptions.importWorkflow")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.importWorkflow")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("3.")} ${i18n.t("menu:menuOptions.configureApiOrCcr")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.configureApiOrCcr")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("4.")} ${i18n.t("menu:menuOptions.configureMcp")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.configureMcp")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("5.")} ${i18n.t("menu:menuOptions.configureModel")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.configureModel")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("6.")} ${i18n.t("menu:menuOptions.configureAiMemory")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.configureAiMemory")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("7.")} ${i18n.t("menu:menuOptions.configureEnvPermission")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.configureEnvPermission")}`
        )}`
      );
      console.log("");
      console.log(`  --------- ${i18n.t("menu:menuSections.otherTools")} ----------`);
      console.log(
        `  ${ansis.cyan("R.")} ${i18n.t("menu:menuOptions.ccrManagement")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.ccrManagement")}`)}`
      );
      console.log(
        `  ${ansis.cyan("U.")} ${i18n.t("menu:menuOptions.ccusage")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.ccusage")}`)}`
      );
      console.log(
        `  ${ansis.cyan("L.")} ${i18n.t("menu:menuOptions.cometixLine")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.cometixLine")}`)}`
      );
      console.log("");
      console.log("  ------------ ZCF ------------");
      console.log(
        `  ${ansis.cyan("0.")} ${i18n.t("menu:menuOptions.changeLanguage")} ${ansis.gray(
          `- ${i18n.t("menu:menuDescriptions.changeLanguage")}`
        )}`
      );
      console.log(
        `  ${ansis.cyan("-.")} ${i18n.t("menu:menuOptions.clearCache")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.clearCache")}`)}`
      );
      console.log(
        `  ${ansis.cyan("+.")} ${i18n.t("menu:menuOptions.checkUpdates")} ${ansis.gray(`- ${i18n.t("menu:menuDescriptions.checkUpdates")}`)}`
      );
      console.log(`  ${ansis.red("Q.")} ${ansis.red(i18n.t("menu:menuOptions.exit"))}`);
      console.log("");
      const { choice } = await inquirer.prompt({
        type: "input",
        name: "choice",
        message: i18n.t("common:enterChoice"),
        validate: (value) => {
          const valid = ["1", "2", "3", "4", "5", "6", "7", "r", "R", "u", "U", "l", "L", "0", "-", "+", "q", "Q"];
          return valid.includes(value) || i18n.t("common:invalidChoice");
        }
      });
      if (!choice) {
        console.log(ansis.yellow(i18n.t("common:cancelled")));
        exitMenu = true;
        break;
      }
      switch (choice.toLowerCase()) {
        case "1":
          await init({ skipBanner: true });
          break;
        case "2":
          await update({ skipBanner: true });
          break;
        case "3":
          await configureApiFeature();
          break;
        case "4":
          await configureMcpFeature();
          break;
        case "5":
          await configureDefaultModelFeature();
          break;
        case "6":
          await configureAiMemoryFeature();
          break;
        case "7":
          await configureEnvPermissionFeature();
          break;
        case "r":
        case "R":
          await runCcrMenuFeature();
          break;
        case "u":
        case "U":
          await runCcusageFeature();
          break;
        case "l":
        case "L":
          await runCometixMenuFeature();
          break;
        case "0": {
          const currentLang = i18n.language;
          await changeScriptLanguageFeature(currentLang);
          break;
        }
        case "-":
          await clearZcfCacheFeature();
          break;
        case "+":
          await checkUpdates();
          break;
        case "q":
          exitMenu = true;
          console.log(ansis.cyan(i18n.t("common:goodbye")));
          break;
      }
      if (!exitMenu && choice.toLowerCase() !== "q") {
        if (choice === "0" || choice === "-" || choice === "+" || choice.toLowerCase() === "u" || choice.toLowerCase() === "r" || choice.toLowerCase() === "l") {
          console.log(`
${ansis.dim("\u2500".repeat(50))}
`);
          continue;
        }
        console.log(`
${ansis.dim("\u2500".repeat(50))}
`);
        const { continue: shouldContinue } = await inquirer.prompt({
          type: "confirm",
          name: "continue",
          message: i18n.t("common:returnToMenu"),
          default: true
        });
        if (!shouldContinue) {
          exitMenu = true;
          console.log(ansis.cyan(i18n.t("common:goodbye")));
        }
      }
    }
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
  }
}

async function ccr(options = {}) {
  try {
    if (!options.skipBanner) {
      displayBannerWithInfo();
    }
    const continueInCcr = await showCcrMenu();
    if (!continueInCcr && !options.skipBanner) {
      await showMainMenu();
    }
  } catch (error) {
    if (!handleExitPromptError(error)) {
      handleGeneralError(error);
    }
  }
}

async function resolveAndSwitchLanguage(lang, options, skipPrompt = false) {
  const zcfConfig = await readZcfConfigAsync();
  const targetLang = options?.allLang || lang || options?.lang || zcfConfig?.preferredLang || (skipPrompt ? "en" : await selectScriptLanguage());
  if (i18n.isInitialized && i18n.language !== targetLang) {
    await changeLanguage(targetLang);
  }
  return targetLang;
}
async function withLanguageResolution(action, skipPrompt = false) {
  return async (...args) => {
    const options = args[0];
    const languageOptions = extractLanguageOptions(options);
    await resolveAndSwitchLanguage(void 0, languageOptions, skipPrompt || languageOptions.skipPrompt);
    return await action(...args);
  };
}
function extractLanguageOptions(options) {
  if (!options || typeof options !== "object" || options === null) {
    return {};
  }
  const obj = options;
  return {
    lang: typeof obj.lang === "string" ? obj.lang : void 0,
    allLang: typeof obj.allLang === "string" ? obj.allLang : void 0,
    skipPrompt: typeof obj.skipPrompt === "boolean" ? obj.skipPrompt : void 0
  };
}
function customizeHelp(sections) {
  sections.unshift({
    title: "",
    body: ansis.cyan.bold(`ZCF - Zero-Config Claude-Code Flow v${version}`)
  });
  sections.push({
    title: ansis.yellow(i18n.t("cli:help.commands")),
    body: [
      `  ${ansis.cyan("zcf")}              ${i18n.t("cli:help.commandDescriptions.showInteractiveMenuDefault")}`,
      `  ${ansis.cyan("zcf init")} | ${ansis.cyan(
        "i"
      )}     ${i18n.t("cli:help.commandDescriptions.initClaudeCodeConfig")}`,
      `  ${ansis.cyan("zcf update")} | ${ansis.cyan("u")}   ${i18n.t("cli:help.commandDescriptions.updateWorkflowFiles")}`,
      `  ${ansis.cyan("zcf ccr")}          ${i18n.t("cli:help.commandDescriptions.configureCcrProxy")}`,
      `  ${ansis.cyan("zcf ccu")} [args]   ${i18n.t("cli:help.commandDescriptions.claudeCodeUsageAnalysis")}`,
      `  ${ansis.cyan("zcf check-updates")} ${i18n.t("cli:help.commandDescriptions.checkUpdateVersions")}`,
      "",
      ansis.gray(`  ${i18n.t("cli:help.shortcuts")}`),
      `  ${ansis.cyan("zcf i")}            ${i18n.t("cli:help.shortcutDescriptions.quickInit")}`,
      `  ${ansis.cyan("zcf u")}            ${i18n.t("cli:help.shortcutDescriptions.quickUpdate")}`,
      `  ${ansis.cyan("zcf check")}        ${i18n.t("cli:help.shortcutDescriptions.quickCheckUpdates")}`
    ].join("\n")
  });
  sections.push({
    title: ansis.yellow(i18n.t("cli:help.options")),
    body: [
      `  ${ansis.green("--lang, -l")} <lang>         ${i18n.t("cli:help.optionDescriptions.displayLanguage")} (zh-CN, en)`,
      `  ${ansis.green("--config-lang, -c")} <lang>  ${i18n.t("cli:help.optionDescriptions.configurationLanguage")} (zh-CN, en)`,
      `  ${ansis.green("--force, -f")}               ${i18n.t("cli:help.optionDescriptions.forceOverwrite")}`,
      `  ${ansis.green("--help, -h")}                ${i18n.t("cli:help.optionDescriptions.displayHelp")}`,
      `  ${ansis.green("--version, -v")}             ${i18n.t("cli:help.optionDescriptions.displayVersion")}`,
      "",
      ansis.gray(`  ${i18n.t("cli:help.nonInteractiveMode")}`),
      `  ${ansis.green("--skip-prompt, -s")}         ${i18n.t("cli:help.optionDescriptions.skipAllPrompts")}`,
      `  ${ansis.green("--api-type, -t")} <type>      ${i18n.t("cli:help.optionDescriptions.apiType")} (auth_token, api_key, ccr_proxy, skip)`,
      `  ${ansis.green("--api-key, -k")} <key>       ${i18n.t("cli:help.optionDescriptions.apiKey")}`,
      `  ${ansis.green("--api-url, -u")} <url>       ${i18n.t("cli:help.optionDescriptions.customApiUrl")}`,
      `  ${ansis.green("--ai-output-lang, -a")} <lang> ${i18n.t("cli:help.optionDescriptions.aiOutputLanguage")}`,
      `  ${ansis.green("--all-lang, -g")} <lang>     ${i18n.t("cli:help.optionDescriptions.setAllLanguageParams")}`,
      `  ${ansis.green("--config-action, -r")} <action> ${i18n.t("cli:help.optionDescriptions.configHandling")} (${i18n.t("cli:help.defaults.prefix")} backup)`,
      `  ${ansis.green("--mcp-services, -m")} <list>  ${i18n.t("cli:help.optionDescriptions.mcpServices")} (${i18n.t("cli:help.defaults.prefix")} all non-key services)`,
      `  ${ansis.green("--workflows, -w")} <list>    ${i18n.t("cli:help.optionDescriptions.workflows")} (${i18n.t("cli:help.defaults.prefix")} all workflows)`,
      `  ${ansis.green("--output-styles, -o")} <styles> ${i18n.t("cli:help.optionDescriptions.outputStyles")} (${i18n.t("cli:help.defaults.prefix")} all custom styles)`,
      `  ${ansis.green("--default-output-style, -d")} <style> ${i18n.t("cli:help.optionDescriptions.defaultOutputStyle")} (${i18n.t("cli:help.defaults.prefix")} engineer-professional)`,
      `  ${ansis.green("--install-cometix-line, -x")} <value> ${i18n.t("cli:help.optionDescriptions.installStatuslineTool")} (${i18n.t("cli:help.defaults.prefix")} true)`
    ].join("\n")
  });
  sections.push({
    title: ansis.yellow(i18n.t("cli:help.examples")),
    body: [
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.showInteractiveMenu")}`),
      `  ${ansis.cyan("npx zcf")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.runFullInitialization")}`),
      `  ${ansis.cyan("npx zcf init")}`,
      `  ${ansis.cyan("npx zcf i")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.updateWorkflowFilesOnly")}`),
      `  ${ansis.cyan("npx zcf u")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.configureClaudeCodeRouter")}`),
      `  ${ansis.cyan("npx zcf ccr")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.runClaudeCodeUsageAnalysis")}`),
      `  ${ansis.cyan("npx zcf ccu")}               ${ansis.gray(`# ${i18n.t("cli:help.defaults.dailyUsage")}`)}`,
      `  ${ansis.cyan("npx zcf ccu monthly --json")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.checkAndUpdateTools")}`),
      `  ${ansis.cyan("npx zcf check-updates")}     ${ansis.gray(`# ${i18n.t("cli:help.defaults.updateTools")}`)}`,
      `  ${ansis.cyan("npx zcf check")}`,
      "",
      ansis.gray(`  # ${i18n.t("cli:help.exampleDescriptions.nonInteractiveModeCicd")}`),
      `  ${ansis.cyan('npx zcf i --skip-prompt --api-type api_key --api-key "sk-ant-..."')}`,
      `  ${ansis.cyan('npx zcf i --skip-prompt --all-lang zh-CN --api-type api_key --api-key "key"')}`,
      `  ${ansis.cyan("npx zcf i --skip-prompt --api-type ccr_proxy")}`,
      ""
    ].join("\n")
  });
  return sections;
}
async function setupCommands(cli) {
  try {
    const zcfConfig = await readZcfConfigAsync();
    const defaultLang = zcfConfig?.preferredLang || "en";
    await initI18n(defaultLang);
  } catch {
  }
  cli.command("", "Show interactive menu (default)").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--all-lang, -g <lang>", "Set all language parameters to this value").option("--config-lang, -c <lang>", "Configuration language (zh-CN, en)").option("--force, -f", "Force overwrite existing configuration").action(await withLanguageResolution(async () => {
    await showMainMenu();
  }));
  cli.command("init", "Initialize Claude Code configuration").alias("i").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--config-lang, -c <lang>", "Configuration language (zh-CN, en)").option("--ai-output-lang, -a <lang>", "AI output language").option("--force, -f", "Force overwrite existing configuration").option("--skip-prompt, -s", "Skip all interactive prompts (non-interactive mode)").option("--config-action, -r <action>", `Config handling (new/backup/merge/docs-only/skip), ${i18n.t("cli:help.defaults.prefix")} backup`).option("--api-type, -t <type>", "API type (auth_token/api_key/ccr_proxy/skip)").option("--api-key, -k <key>", "API key (used for both API key and auth token types)").option("--api-url, -u <url>", "Custom API URL").option("--mcp-services, -m <services>", `Comma-separated MCP services to install (context7,mcp-deepwiki,Playwright,exa), "skip" to skip all, "all" for all non-key services, ${i18n.t("cli:help.defaults.prefix")} all`).option("--workflows, -w <workflows>", `Comma-separated workflows to install (sixStepsWorkflow,featPlanUx,gitWorkflow,bmadWorkflow), "skip" to skip all, "all" for all workflows, ${i18n.t("cli:help.defaults.prefix")} all`).option("--output-styles, -o <styles>", `Comma-separated output styles (engineer-professional,nekomata-engineer,laowang-engineer,default,explanatory,learning), "skip" to skip all, "all" for all custom styles, ${i18n.t("cli:help.defaults.prefix")} all`).option("--default-output-style, -d <style>", `Default output style, ${i18n.t("cli:help.defaults.prefix")} engineer-professional`).option("--all-lang, -g <lang>", "Set all language parameters to this value").option("--install-cometix-line, -x <value>", `Install CCometixLine statusline tool (true/false), ${i18n.t("cli:help.defaults.prefix")} true`).action(await withLanguageResolution(async (options) => {
    await init(options);
  }));
  cli.command("update", "Update Claude Code prompts only").alias("u").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--all-lang, -g <lang>", "Set all language parameters to this value").option("--config-lang, -c <lang>", "Configuration language (zh-CN, en)").action(await withLanguageResolution(async (options) => {
    await update(options);
  }));
  cli.command("ccr", "Configure Claude Code Router for model proxy").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--all-lang, -g <lang>", "Set all language parameters to this value").action(await withLanguageResolution(async () => {
    await ccr();
  }));
  cli.command("ccu [...args]", "Run Claude Code usage analysis tool").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--all-lang, -g <lang>", "Set all language parameters to this value").allowUnknownOptions().action(await withLanguageResolution(async (args) => {
    await executeCcusage(args);
  }));
  cli.command("check-updates", "Check and update Claude Code and CCR to latest versions").alias("check").option("--lang, -l <lang>", "ZCF display language (zh-CN, en)").option("--all-lang, -g <lang>", "Set all language parameters to this value").action(await withLanguageResolution(async () => {
    await checkUpdates();
  }));
  cli.help((sections) => customizeHelp(sections));
  cli.version(version);
}

async function main() {
  const cli = cac("zcf");
  await setupCommands(cli);
  cli.parse();
}
main().catch(console.error);
